
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>7.1. Hàm mất mát của SVM &#8212; Deep AI KhanhBlog</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/my.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"TeX": {"Macros": {"N": "\\mathbb{N}", "floor": ["\\lfloor#1\\rfloor", 1], "bmat": ["\\left[\\begin{array}"], "emat": ["\\end{array}\\right]"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="canonical" href="https://phamdinhkhanh.github.io/deepai-book/ch_ml/SVM.html" />
    <link rel="shortcut icon" href="../_static/logo.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="8. Khái niệm về cây quyết định" href="index_DecisionTree.html" />
    <link rel="prev" title="7. Giới thiệu về SVM" href="index_SVM.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/ML_course_logos.jpeg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Deep AI KhanhBlog</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Lời nói đầu
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Giới thiệu
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../contents.html">
   Các chương dự kiến
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ch_intro/main_contents.html">
   Mục tiêu cuốn sách
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../latex.html">
   Latex
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../grossary.html">
   Bảng thuật ngữ
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Phụ lục
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/appendix_dtypes.html">
   1. Định dạng dữ liệu
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_dtypes_basic.html">
     1.1. Các định dạng số, boolean và ký tự
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/index_pandas.html">
   2. Pandas
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_pandas.html">
     2.1. Khởi tạo dataframe
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/index_numpy.html">
   3. Numpy
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_numpy.html">
     3.1. Khởi tạo một mảng trên numpy
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/index_matplotlib.html">
   4. Matplotlib
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_matplotlib.html">
     4.1. Format chung của một biểu đồ trên matplotlib
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/index_OOP.html">
   5. Lập trình hướng đối tượng (Object Oriented Programming - OOP)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_OOP.html">
     5.1. Class và Object
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/index_pipeline.html">
   6. Sklearn Pipeline
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_pipeline.html">
     6.1. Thiết kế pipeline
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/index_Convex_Opt.html">
   7. Giới thiệu chung về optimization
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_Convex_Opt.html">
     7.1. Bài toán dạng tổng quát
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Đại số tuyến tính
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../ch_algebra/appendix_algebra.html">
   1. Đại số tuyến tính
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Giới thiệu
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../ch_calculus/appendix_calculus.html">
   1. Giải tích tích phân
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Xác suất
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../ch_probability/appendix_probability.html">
   1. Xác suất
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Machine Learning
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="index_MLIntroduce.html">
   1. Khái quát Machine Learning
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_prediction.html">
   2. Bài toán dự báo
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="prediction.html">
     2.1. Ứng dụng của hồi qui tuyến tính
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_RidgedRegression.html">
   2.2. Hồi qui Ridge và Lasso
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="RidgedRegression.html">
     2.2.2. Hồi qui Ridge
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_classification.html">
   3. Bài toán phân loại
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="classification.html">
     3.1. Hồi qui Logistic
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_OvfAndUdf.html">
   4. Độ chệch (
   <em>
    bias
   </em>
   ) và phương sai (
   <em>
    variance
   </em>
   )
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="OvfAndUdf.html">
     4.1. Sự đánh đổi giữa độ chệch và phương sai
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_ModelMetric.html">
   5. Thước đo mô hình phân loại
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
  <label for="toctree-checkbox-12">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="modelMetric.html">
     5.1. Bộ dữ liệu
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_creditScorecard.html">
   6. Ứng dụng mô hình scorecard
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
  <label for="toctree-checkbox-13">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="creditScorecard.html">
     6.1. Phương pháp chuyên gia và mô hình
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="index_SVM.html">
   7. Giới thiệu về SVM
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/>
  <label for="toctree-checkbox-14">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     7.1. Hàm mất mát của SVM
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_DecisionTree.html">
   8. Khái niệm về cây quyết định
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/>
  <label for="toctree-checkbox-15">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="DecisionTree.html">
     8.1. Mô hình cây quyết định (
     <em>
      decision tree
     </em>
     )
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_RandomForest.html">
   9. Giới thiệu về mô hình rừng cây (
   <em>
    Random Forest
   </em>
   )
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/>
  <label for="toctree-checkbox-16">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="RandomForest.html">
     9.1. Ý tưởng của mô hình rừng cây
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_Bayes.html">
   10. Bạn là
   <em>
    Tần suất
   </em>
   (
   <em>
    Frequentist
   </em>
   ) hay
   <em>
    Bayesian
   </em>
   ?
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/>
  <label for="toctree-checkbox-17">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="NaiveBayes.html">
     10.1. Ước lượng hợp lý tối đa (
     <em>
      Maximum Likelihood Function - MLE
     </em>
     )
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_FeatureEngineering.html">
   11. Giới thiệu về feature engineering
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" type="checkbox"/>
  <label for="toctree-checkbox-18">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="FeatureEngineering.html">
     11.1. Feature Engineering
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_Boosting.html">
   12. Phương pháp tăng cường (
   <em>
    Boosting
   </em>
   )
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" type="checkbox"/>
  <label for="toctree-checkbox-19">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="Boosting.html">
     12.1. AdaBoosting
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_KMeans.html">
   13. k-Means Clustering
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-20" name="toctree-checkbox-20" type="checkbox"/>
  <label for="toctree-checkbox-20">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="KMeans.html">
     13.1. Các bước của thuật toán k-Means Clustering
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_HierarchicalClustering.html">
   14. Hierarchical Clustering (
   <em>
    phân cụm phân cấp
   </em>
   )
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-21" name="toctree-checkbox-21" type="checkbox"/>
  <label for="toctree-checkbox-21">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="HierarchicalClustering.html">
     14.1. Chiến lược hợp nhất (
     <em>
      agglomerative
     </em>
     )
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_DBSCAN.html">
   15. DBSCAN
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-22" name="toctree-checkbox-22" type="checkbox"/>
  <label for="toctree-checkbox-22">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="DBSCAN.html">
     15.1. Phương pháp phân cụm dựa trên mật độ (
     <em>
      Density-Based Clustering
     </em>
     )
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_GMM.html">
   16. Gaussian Mixture Model
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-23" name="toctree-checkbox-23" type="checkbox"/>
  <label for="toctree-checkbox-23">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="GMM.html">
     16.1. Ước lượng MLE cho
     <em>
      phân phối Gaussian đa chiều
     </em>
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_PCA.html">
   17. Giảm chiều dữ liệu
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-24" name="toctree-checkbox-24" type="checkbox"/>
  <label for="toctree-checkbox-24">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="PCA.html">
     17.1. Phương pháp phân tích suy biến
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Đóng góp từ những tác giả khác
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../ch_donation/fubini_and_riemann.html">
   Tích phân Riemann và định lý Fubini
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ch_donation/information_theory.html">
   Lý thuyết thông tin
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="../_sources/ch_ml/SVM.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/ch_ml/SVM.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/phamdinhkhanh/deepai-book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/phamdinhkhanh/deepai-book/issues/new?title=Issue%20on%20page%20%2Fch_ml/SVM.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/phamdinhkhanh/deepai-book/edit/main/book/ch_ml/SVM.md"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/phamdinhkhanh/deepai-book/main?urlpath=tree/book/ch_ml/SVM.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   7.1. Hàm mất mát của SVM
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#goc-nhin-tu-hoi-qui-logistic">
     7.1.1. Góc nhìn từ hồi qui Logistic
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#tu-logistic-toi-svm">
     7.1.2. Từ Logistic tới SVM
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#duong-bien-va-le-trong-svm">
   7.2. Đường biên và lề trong SVM
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bai-toan-toi-uu-svm">
   7.3. Bài toán tối ưu SVM
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#he-dieu-kien-kkt">
     7.3.1. Hệ điều kiện KKT
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bai-toan-toi-uu-bac-hai-quadratic-optimization">
     7.3.2. Bài toán tối ưu bậc hai (
     <em>
      Quadratic Optimization
     </em>
     )
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#he-dieu-kien-kkt-doi-voi-bai-toan-quadratic">
     7.3.3. Hệ điều kiện
     <em>
      KKT
     </em>
     đối với bài toán Quadratic
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bai-toan-doi-ngau-svm">
     7.3.4. Bài toán đối ngẫu SVM
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#du-bao-nhan">
     7.3.5. Dự báo nhãn
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sorf-margin-classification">
   7.4. Sorf Margin Classification
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#so-sanh-giua-le-cung-hard-margin-va-le-mem-soft-margin">
     7.4.1. So sánh giữa lề cứng (
     <em>
      hard margin
     </em>
     ) và lề mềm (
     <em>
      soft margin
     </em>
     )
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#suy-xet-lai-ham-chi-phi-cho-phan-loai-duong-bien-mem-svm">
     7.4.2. Suy xét lại hàm chi phí cho phân loại đường biên mềm SVM
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ky-thuat-tao-dac-trung">
   7.5. Kỹ thuật tạo đặc trưng
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dac-trung-da-thuc-polynormial-features">
     7.5.1. Đặc trưng đa thức (
     <em>
      Polynormial Features
     </em>
     )
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dac-trung-tuong-dong-gaussian-rbf">
     7.5.2. Đặc trưng tương đồng Gaussian RBF
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#kernel-trong-svm">
   7.6. Kernel trong SVM
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#khai-niem-ham-kernel-kernel-function-va-khong-gian-hilbert">
     7.6.1. Khái niệm hàm kernel (
     <em>
      Kernel function
     </em>
     ) và không gian Hilbert
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#dinh-ly-merce-ve-kernel">
     7.6.2. Định lý merce về kernel
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cac-kernel-khac-cho-svm">
     7.6.3. Các kernel khác cho SVM
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     7.6.4. Dự báo nhãn
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#vi-du-ve-bai-toan-svm">
   7.7. Ví dụ về bài toán SVM
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bai-toan-svm-cho-du-lieu-dang-phi-tuyen">
     7.7.1. Bài toán SVM cho dữ liệu dạng phi tuyến
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#su-dung-kernel-svm">
     7.7.2. Sử dụng kernel SVM
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#tuning-sieu-tham-so-cho-mot-kernel">
     7.7.3. tuning siêu tham số cho một kernel
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tong-ket">
   7.8. Tổng kết
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bai-tap">
   7.9. Bài tập
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tai-lieu">
   7.10. Tài liệu
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="ham-mat-mat-cua-svm">
<h1>7.1. Hàm mất mát của SVM<a class="headerlink" href="#ham-mat-mat-cua-svm" title="Permalink to this headline">¶</a></h1>
<div class="section" id="goc-nhin-tu-hoi-qui-logistic">
<h2>7.1.1. Góc nhìn từ hồi qui Logistic<a class="headerlink" href="#goc-nhin-tu-hoi-qui-logistic" title="Permalink to this headline">¶</a></h2>
<p>Trong <a class="reference external" href="https://phamdinhkhanh.github.io/deepai-book/ch_ml/classification.html">hồi qui Logistic</a> chúng ta đã làm quen với <em>hàm mất mát</em> (<em>loss function</em>) dạng:</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(\mathbf{w}) = \sum_{i=1}^{n} -[y_i\log(\hat{y_i}) + (1-y_i)\log(1-\hat{y}_i)]\]</div>
<p>Bản chất của hàm mất mát trong hồi qui Logistic là một <em>thước đo</em> về sự tương quan giữa phân phối xác suất dự báo với <em>ground truth</em>.</p>
<p>Trong đó phân phối xác suất được ước tính dựa trên hàm <code class="docutils literal notranslate"><span class="pre">Sigmoid</span></code> theo công thức <span class="math notranslate nohighlight">\(\hat{y} = \sigma(z) = \frac{1}{1+e^{-z}}\)</span>.</p>
<p>Ta cũng biết rằng đường biên phân loại của hồi qui Logistic là một siêu phẳng có phương trình <span class="math notranslate nohighlight">\(\mathbf{w}^{\intercal}\mathbf{x}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{split}
\hat{y} = \left\{
\begin{matrix}
1 \text{ if } \mathbf{w}^{\intercal}\mathbf{x} &gt; 0 \\
0 \text{ if } \mathbf{w}^{\intercal}\mathbf{x} \leq 0
\end{matrix}
\right.\end{split}
\end{split}\]</div>
<p>Tiếp theo chúng ta sẽ cùng phân tích <em>hàm mất mát</em> của mô hình trong hai trường hợp <span class="math notranslate nohighlight">\(y=0\)</span> và <span class="math notranslate nohighlight">\(y=1\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{split}
\mathcal{L}(\mathbf{w}) = \left\{
\begin{matrix}
-\log(\hat{y_i}) ~~\text{ if }  y_i=1 \\
-\log(1-\hat{y}_i) \text{ if } y_i=0
\end{matrix}
\right.\end{split}
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
  <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>

<span class="n">y0</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">))</span> <span class="c1"># Trường hợp ground truth = 0</span>
<span class="n">y1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">))</span> <span class="c1"># Trường hợp ground truth = 1</span>

<span class="c1"># Hàm mất mát nếu ground truth = 1</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;L(y, yhat)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;y=1&#39;</span><span class="p">)</span>

<span class="c1"># Hàm mất mát nếu ground truth = 0</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;L(y, yhat)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;y=0&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/SVM_2_0.png" src="../_images/SVM_2_0.png" />
</div>
</div>
<p>Ta nhận thấy hình dạng của <em>hàm mất mát</em> trong hai trường hợp tương ứng với <span class="math notranslate nohighlight">\(y=1\)</span> và <span class="math notranslate nohighlight">\(y=0\)</span> là trái ngược nhau:</p>
<ul class="simple">
<li><p>Đối với trường hợp nhãn <span class="math notranslate nohighlight">\(y = 1\)</span>: Khi giá trị của <span class="math notranslate nohighlight">\(z\)</span> càng lớn thì hàm mất mát sẽ tiệm cận 0. Điều đó đồng nghĩa với mô hình sẽ phạt ít những trường hợp <span class="math notranslate nohighlight">\(z\)</span> lớn và có nhãn 0. Những trường hợp này tương ứng với những điểm nằm cách xa đường biên phân chia.</p></li>
<li><p>Đối với nhãn <span class="math notranslate nohighlight">\(y=0\)</span> thì trái lại, mô hình có xu hướng phạt ít với những giá trị <span class="math notranslate nohighlight">\(z\)</span> nhỏ. Khi đó những điểm này sẽ nằm cách xa đường biên về phía nửa mặt phẳng <span class="math notranslate nohighlight">\(y=1\)</span>.</p></li>
</ul>
<p>Những phân tích ở trên là hợp lý vì ở các mức giá trị <span class="math notranslate nohighlight">\(z\)</span> đủ lớn hoặc đủ nhỏ thì đều là các điểm nằm cách xa đường biên phân chia nên chúng ta có thể dễ dàng dự báo đúng nhãn cho chúng. Việc phạt những điểm này nếu phân loại sai không mang nhiều ý nghĩa bằng phạt những điểm nằm gần đường biên và được xem như là case khó (<em>hard case</em>). Thậm chí nếu phạt những điểm nằm xa đường biên một giá trị lớn dễ khiến xảy ra nguy cơ <em>quá khớp</em> vì hầu hết những điểm đó đều là <em>ngoại lai</em>.</p>
</div>
<div class="section" id="tu-logistic-toi-svm">
<h2>7.1.2. Từ Logistic tới SVM<a class="headerlink" href="#tu-logistic-toi-svm" title="Permalink to this headline">¶</a></h2>
<p>Trong SVM chúng ta có một thay đổi đột phá đó là tìm cách xấp xỉ hàm mất mát dạng cross-entropy của Logistic bằng một hàm mà chỉ phạt những điểm ở gần đường biên thay vì phạt những điểm ở xa đường biên bằng cách đưa mức phạt về 0.</p>
<p>Cụ thể đó là hai hàm phạt <span class="math notranslate nohighlight">\(\text{cost}_1()\)</span> và <span class="math notranslate nohighlight">\(\text{cost}_2()\)</span> tương ứng với <span class="math notranslate nohighlight">\(y=0\)</span> và <span class="math notranslate nohighlight">\(y=1\)</span> như bên dưới:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\left\{
\begin{matrix}
\text{cost}_1(z) = \max(1+z, 0) ~ \text{if } y=0 \\
\text{cost}_2(z) = \max(0, 1-z) ~ \text{if } y=1
\end{matrix}
\right.\end{split}\end{split}\]</div>
<p>Hai hàm này thể hiện chi phí phải bỏ ra nếu phân loại sai các nhãn lần lượt thuộc <span class="math notranslate nohighlight">\(0\)</span> hoặc <span class="math notranslate nohighlight">\(1\)</span>. Dạng tổng quát của chúng là <span class="math notranslate nohighlight">\(\max(0, t)\)</span> còn được gọi là hàm hingloss. Đây là một trong những hàm mất mát mà bạn sẽ gặp khá nhiều trong machine learning.</p>
<p>Bên dưới là hình dạng của hai hàm <span class="math notranslate nohighlight">\(\text{cost}_1()\)</span> và <span class="math notranslate nohighlight">\(\text{cost}_2()\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
  <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>

<span class="n">y0</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">))</span> <span class="c1"># Trường hợp ground truth = 0</span>
<span class="n">y1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">))</span> <span class="c1"># Trường hợp ground truth = 1</span>

<span class="n">cost1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># Trường hợp ground truth = 0</span>
<span class="n">cost2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">z</span><span class="p">)</span> <span class="c1"># Trường hợp ground truth = 1</span>

<span class="c1"># Hàm mất mát nếu ground truth = 1</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">cost2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;L(y, yhat)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cross-entropy&#39;</span><span class="p">,</span> <span class="s1">&#39;cost2&#39;</span><span class="p">])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;y=1&#39;</span><span class="p">)</span>

<span class="c1"># Hàm mất mát nếu ground truth = 0</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">cost1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;L(y, yhat)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cross-entropy&#39;</span><span class="p">,</span> <span class="s1">&#39;cost1&#39;</span><span class="p">])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;y=0&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/SVM_5_0.png" src="../_images/SVM_5_0.png" />
</div>
</div>
<p>Ta nhận thấy hình dạng của các hàm mất mát <span class="math notranslate nohighlight">\(\text{cost}_1\)</span> và <span class="math notranslate nohighlight">\(\text{cost}_2\)</span> cũng gần tương tự như cross-entropy. Điểm khác biệt chính đó là giá trị của mất mát bằng 0 nếu <span class="math notranslate nohighlight">\(z \geq 1\)</span> (đối với nhãn <span class="math notranslate nohighlight">\(y=1\)</span>) hoặc <span class="math notranslate nohighlight">\(z \leq -1\)</span> (đối với nhãn <span class="math notranslate nohighlight">\(y=0\)</span>). Theo các hàm mất mát mới này, chúng ta bỏ qua việc phạt phân loại sai những điểm nằm xa đường biên. Đối với những điểm nằm gần đường biên nhất thì mới ảnh hưởng tới hàm mất mát. Tập hợp những điểm nằm gần đường biên sẽ giúp xác định đường biên và được gọi là <em>tập tập hỗ trợ</em> (<em>support vector</em>).</p>
<p>Như vậy sau khi thay đổi hàm phạt ta thu được hàm mất mát mới dạng:</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(\mathbf{w}) = \sum_{i=1}^{n} -[y_i\text{cost}_1(\hat{y_i}) + (1-y_i)\text{cost}_2(1-\hat{y}_i)]\]</div>
<p>SVM cho phép ta giảm thiểu <em>quá khớp</em> thông qua một thành phần điều chuẩn cũng tương tự như hồi qui Logistic.</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(\mathbf{w}) = C(\sum_{i=1}^{n} -[y_i\text{cost}_1(\hat{y_i}) + (1-y_i)\text{cost}_2(1-\hat{y}_i)])+\frac{\lambda}{2} \underbrace{||\mathbf{w}||_2^2}_{\text{regularization term}}\]</div>
<p>Trong công thức trên thì hằng số <span class="math notranslate nohighlight">\(C &gt; 0\)</span> thể hiện ảnh hưởng của sai số phân loại lên hàm mất mát. Trong khi <span class="math notranslate nohighlight">\(\lambda &gt; 0\)</span> là hằng số của thành phần điều chuẩn (<em>regularization term</em>) thể hiện tác động của độ lớn trọng số hồi qui <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> lên hàm mất mát.</p>
<p>Khi tăng tỷ lệ <span class="math notranslate nohighlight">\(\frac{\lambda}{C}\)</span> có thể giúp các trọng số của mô hình được kiểm soát về độ lớn, thông qua đó làm cho độ phức tạp của đường biên phân chia giảm và kiểm soát hiện tượng <em>quá khớp</em>.</p>
<p>Đối với phương trình hồi qui Logistic thì chúng ta sẽ xác định nhãn dựa trên dấu của <span class="math notranslate nohighlight">\(\mathbf{w}^{\intercal}\mathbf{x}\)</span>. Còn trong thuật toán SVM, đối với một tập dữ liệu mà các nhãn là phân tuyến (<em>linear seperable</em>) (tức là tồn tại ít nhất 1 đường biên phân loại đúng toàn bộ các điểm) thì chúng ta sẽ mở rộng đường biên phân chia về hai phía là 1 đơn vị. Khi đó một điểm được dự báo là:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\hat{y} = \left\{
\begin{matrix}
0 ~ \text{if } \mathbf{w}^{\intercal}\mathbf{x} \leq -1 \\
1 ~ \text{if } \mathbf{w}^{\intercal}\mathbf{x} \geq 1 
\end{matrix}
\right.\end{split}\end{split}\]</div>
<p>Ý nghĩa của việc mở rộng đường biên đó là khiến cho các điểm nằm gần với đường biên sẽ trở nên tách biệt hơn. Tiếp theo chúng ta sẽ tìm hiểu cơ chế nào hoạt động và cách xác định đường biên đối với thuật toán SVM.</p>
</div>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="duong-bien-va-le-trong-svm">
<h1>7.2. Đường biên và lề trong SVM<a class="headerlink" href="#duong-bien-va-le-trong-svm" title="Permalink to this headline">¶</a></h1>
<p><strong>Tập dữ liệu của bài toán SVM</strong></p>
<p>Giả sử tập dữ liệu huấn luyện <span class="math notranslate nohighlight">\(\mathcal{Z}\)</span> bao gồm <span class="math notranslate nohighlight">\(N\)</span> điểm dữ liệu. Trong đó điểm dữ liệu thứ <span class="math notranslate nohighlight">\(i\)</span> là <span class="math notranslate nohighlight">\(Z_i = (\mathbf{x}_i, y_i)\)</span> với <span class="math notranslate nohighlight">\(\mathbf{x}_i \in \mathbb{R}^{d}\)</span> là véc tơ đầu vào và <span class="math notranslate nohighlight">\(y_i\)</span> là biến mục tiêu là một trong hai giá trị <span class="math notranslate nohighlight">\(\{-1, 1\}\)</span>. Tập dữ liệu này được giả định là <em>phân tuyến</em> (<em>linear seperable</em>).</p>
<p>Bên dưới là hình ảnh tập dữ liệu <em>phân tuyến</em>, đường biên và lề trong thuật toán SVM.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">svm</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>


<span class="c1"># we create 40 separable points</span>
<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">cluster_std</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">idx_cls_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">idx_cls_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># fit the model, don&#39;t regularize for illustration purposes</span>
<span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">idx_cls_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">idx_cls_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">idx_cls_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">idx_cls_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="c1"># plot the decision function</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">xlim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
<span class="n">ylim</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>

<span class="c1"># create grid to evaluate model</span>
<span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">YY</span><span class="p">,</span> <span class="n">XX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">)</span>
<span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">XX</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">YY</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">XX</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">B</span><span class="o">-</span><span class="mf">0.9</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">B</span><span class="o">+</span><span class="mf">0.8</span>
<span class="c1"># plot decision boundary and margins</span>
<span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span>  <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
           <span class="n">linestyles</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;--&#39;</span><span class="p">])</span>

<span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
           <span class="n">linestyles</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">])</span>

<span class="n">ax</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
           <span class="n">linestyles</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">])</span>

<span class="c1"># plot support vectors</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">support_vectors_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">clf</span><span class="o">.</span><span class="n">support_vectors_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
           <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/SVM_10_0.png" src="../_images/SVM_10_0.png" />
</div>
</div>
<p><strong>Hình 1:</strong> Hình ảnh về tập dữ liệu trong bài toán phân loại nhị phân mà các lớp là <em>phân tuyến</em>. Ba đường thẳng <code class="docutils literal notranslate"><span class="pre">A,</span> <span class="pre">B,</span> <span class="pre">C</span></code> đại diện cho ba đường biên phân chia đúng <strong>mọi điểm dữ liệu</strong>. Những điểm hình tròn nằm bên trái thuộc mặt dương có nhãn <span class="math notranslate nohighlight">\(y=1\)</span>, những điểm hình sao nhằm bên phải thuộc mặt âm nhãn <span class="math notranslate nohighlight">\(y=-1\)</span>. Sở dĩ chúng ta gán nhãn như vậy là vì tại cùng một dữ liệu đầu vào <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> thì mặt dương bên trái sẽ có giá trị lớn hơn mặt âm bên phải.</p>
<p><strong>Lựa chọn đường biên phân chia tương ứng với một phương</strong></p>
<p>Ba đường thẳng <code class="docutils literal notranslate"><span class="pre">A,</span> <span class="pre">B,</span> <span class="pre">C</span></code> ở ví dụ trên là ba đường biên phân chia song song và có cùng phương. Trong ba đường biên phân chia thì đường biên <code class="docutils literal notranslate"><span class="pre">B</span></code> là công bằng nhất vì chúng cách đều các điểm gần nhất thuộc hai lớp. Còn lựa chọn <code class="docutils literal notranslate"><span class="pre">A</span></code> và <code class="docutils literal notranslate"><span class="pre">C</span></code> sẽ không công bằng vì chúng ta sẽ dễ thiên vị một lớp hơn lớp còn lại.</p>
<p>Như vậy để cho công bằng thì đường biên phải luôn <strong>nằm chính giữa</strong> và <strong>cách đều</strong> các điểm gần nhất với nó. Đồng thời đối với bài toán Hard-Margin SVM thì tập dữ liệu là phân tuyến nên đường biên cần phải phân loại đúng mọi điểm dữ liệu. Chúng ta coi độ rộng của đường biên là lề (<em>margin</em>). Ngoài ra tập hợp những điểm nằm sát đường biên nhất thì được gọi là <em>tập hỗ trợ</em>. Những điểm này sẽ hỗ trợ tìm ra đường biên vì những đường thẳng nét đứt đi qua chúng song song với đường biên.</p>
<p>Trong không gian hai chiều thì đường biên là một đường thẳng. Trong không gian 3 chiều chúng sẽ là một mặt phẳng (<em>plane</em>). Trong không gian nhiều hơn 3 chiều chúng ta gọi đường biên phân chia là siêu phẳng (<em>hyperplane</em>).</p>
<p>Một câu hỏi đặt ra đó là có vô số những đường biên phân loại, vậy thì đường biên nào là phù hợp nhất?</p>
<p>Mục tiêu của SVM đó là tìm ra một siêu phẳng (<em>hyperplane</em>) trong không gian <span class="math notranslate nohighlight">\(d\)</span> chiều làm đường biên phân chia sao cho độ rộng <strong>lề</strong> của chúng là lớn nhất vì khi phân chia theo đường biên này thì các nhóm là tách biệt nhất.</p>
<p><img alt="" src="https://i.imgur.com/oKeJOcW.jpeg" /></p>
<p><strong>Hình 2:</strong> Hình ảnh các trường hợp của đường biên phân chia với các phương khác nhau đối với một tập dữ liệu <em>phân tuyến</em>. Các đường nét đậm (<span class="math notranslate nohighlight">\(B\)</span> và <span class="math notranslate nohighlight">\(D\)</span>) được gọi là đường biên dùng để xác định nhãn dự báo. Các đường nét nhạt đối xứng về hai phía qua đường biên được gọi là <em>mép của lề</em> và khoảng cách độ rộng từ <em>mép của lề</em> tới đường biên được gọi là lề (<em>margin</em>). Những điểm được khoanh tròn gần với vị trí của đường biên nhất sẽ được sử dụng để xác định <em>mép của lề</em> (ta sẽ chứng minh đều này ở bài toán đối ngẫu SVM) và thông qua đó xác định đường biên, tập hợp những điểm này được gọi là tập hỗ trợ  <span class="math notranslate nohighlight">\(S\)</span> (<em>support vector</em>). Một đường biên phân chia càng tốt hai tập dữ liệu nếu như độ rộng <em>lề</em> càng lớn.</p>
<p><strong>Khoảng cách từ một điểm tới một siêu phẳng</strong></p>
<p>Giả sử phương trình của đường biên phân chia hai điểm dữ liệu là:</p>
<div class="math notranslate nohighlight">
\[b + w_1 x_1 + w_2 x_2 + \dots + w_N x_N = b + \mathbf{w}^{\intercal}\mathbf{x} = 0\]</div>
<p><span class="math notranslate nohighlight">\(b\)</span> là hệ số tự do, <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> là các véc tơ hệ số. <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> là véc tơ quan sát đầu vào.</p>
<p>Trong chương trình THPT chúng ta đã được học về công thức khoảng cách từ một điểm <span class="math notranslate nohighlight">\(A = (x_1, x_2)\)</span> tới một đường thẳng <span class="math notranslate nohighlight">\(l\)</span> có phương trình <span class="math notranslate nohighlight">\(b + w_1 x_1 + w_2 x_2 = 0\)</span> là:</p>
<div class="math notranslate nohighlight">
\[d(A, l) = \frac{|b + w_1 x_1 + w_2 x_2|}{\sqrt{w_1^2 + w_2^2}} = \frac{|b + w_1 x_1 + w_2 x_2|}{||\mathbf{w}||_2}\]</div>
<p>Trong trường hợp tổng quát, khoảng cách từ một điểm bất kỳ <span class="math notranslate nohighlight">\(Z_i = (\mathbf{x}_i, y_i)\)</span> tới đường biên là siêu phẳng <span class="math notranslate nohighlight">\(H\)</span> có phương trình <span class="math notranslate nohighlight">\(b+\mathbf{w}^{\intercal}\mathbf{x} = 0\)</span> sẽ là:</p>
<div class="math notranslate nohighlight">
\[d(Z_i, H) = \frac{|b+\mathbf{w}^{\intercal}\mathbf{x}_i|}{||\mathbf{w}||_2} = \frac{y_i(b+\mathbf{w}^{\intercal}\mathbf{x}_i)}{||\mathbf{w}||_2}\]</div>
<p>Trong công thức trên thì <span class="math notranslate nohighlight">\(|b+\mathbf{w}^{\intercal}\mathbf{x}| = y_i(b+\mathbf{w}^{\intercal}\mathbf{x}_i)\)</span> là vì:</p>
<ul class="simple">
<li><p>Xét trường hợp nhãn <span class="math notranslate nohighlight">\(y_i=-1\)</span> thì điểm <span class="math notranslate nohighlight">\(Z_i\)</span> nằm ở mặt âm và có <span class="math notranslate nohighlight">\(b+\mathbf{w}^{\intercal}\mathbf{x}_i \leq 0\)</span>. Do đó <span class="math notranslate nohighlight">\(y_i(b+\mathbf{w}^{\intercal}\mathbf{x}_i) \geq 0\)</span>.</p></li>
<li><p>Xét trường hợp nhãn <span class="math notranslate nohighlight">\(y_i = 1\)</span> thì <span class="math notranslate nohighlight">\(Z_i\)</span> nằm ở mặt dương và có <span class="math notranslate nohighlight">\(b+\mathbf{w}^{\intercal}\mathbf{x}_i \geq 0\)</span>. Từ đó suy ra  <span class="math notranslate nohighlight">\(y_i(b+\mathbf{w}^{\intercal}\mathbf{x}_i) \geq 0\)</span>.</p></li>
</ul>
<p>Trong cả hai trường hợp thì đẳng thức <span class="math notranslate nohighlight">\(|b+\mathbf{w}^{\intercal}\mathbf{x}| = y_i(b+\mathbf{w}^{\intercal}\mathbf{x}_i)\)</span> luôn xảy ra.</p>
<p><strong>Tìm đường biên có lề lớn nhất</strong></p>
<p>Tập hợp các điểm nằm gần nhất với một đường biên sẽ giúp xác định phương trình đường biên nên chúng còn được gọi là tập hợp các <em>điểm hỗ trợ</em> (<em>support points</em>), ký hiệu là <span class="math notranslate nohighlight">\(\mathcal{S}\)</span>. Trong hình 2 thì các điểm được khoanh tròn chính là các điểm thuộc tập hỗ trợ. Để tìm ra đường biên có độ rộng lề là lớn nhất thì chúng ta cần tối đa hoá khoảng cách từ các điểm thuộc tập hỗ trợ tới đường biên. Điều này tương đương với giải bài toán tối ưu:</p>
<div class="math notranslate nohighlight">
\[\begin{eqnarray}
\hat{\mathbf{w}}, \hat{b} &amp; = &amp; \arg \max \{\min_{(\mathbf{x}_i, y_i) \in \mathcal{Z}} \frac{b+y_i(\mathbf{w}^{\intercal}\mathbf{x}_i)}{||\mathbf{w}||_2} \} \
\end{eqnarray} \tag{1}\]</div>
<p>Khi nhân vào phương trình đường biên với một hệ số <span class="math notranslate nohighlight">\(k\)</span> thì đường biên không thay đổi. Do đó khoảng cách từ mọi điểm tới đường biên không thay đổi. Tức là khoảng cách từ các điểm thuộc tập hỗ trợ tới đường biên không thay đổi và dẫn tới độ rộng của lề là không thay đổi. Nhờ tính chất này chúng ta có thể nhân thêm vào các trọng số <span class="math notranslate nohighlight">\(w_i\)</span> của phương trình đường biên một hệ số <span class="math notranslate nohighlight">\(k\)</span> sao cho với các điểm dữ liệu thuộc tập hỗ trợ <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> thì <span class="math notranslate nohighlight">\(b+y_i(\mathbf{w}^{\intercal}\mathbf{x}_i) = 1\)</span>. Điều đó cũng đồng nghĩa với luôn tìm được một cách nhân với <span class="math notranslate nohighlight">\(k\)</span> sao cho đường biên:</p>
<div class="math notranslate nohighlight">
\[\min_{(\mathbf{x}_i, y_i) \in \mathcal{Z}} b+y_i(\mathbf{w}^{\intercal}\mathbf{x}_i) = 1\]</div>
<p>Thay vào <span class="math notranslate nohighlight">\((1)\)</span> thì bài toán tìm nghiệm <span class="math notranslate nohighlight">\(\hat{\mathbf{w}}, \hat{b}\)</span> tương ứng với bài toán tối ưu với ràng buộc tuyến tính:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}
\hat{\mathbf{w}}, \hat{b} &amp; = &amp; \arg \max \frac{1}{||\mathbf{w}||_2} \\
\text{subject} &amp; : &amp; y_i(b+\mathbf{w}^{\intercal}\mathbf{x}_i) \geq 1, \forall i=\overline{1, N} ~~~~~~~~~~~~
\tag{2}\end{eqnarray}\end{split}\]</div>
<p>Điều kiện ràng buộc <span class="math notranslate nohighlight">\(y_i(b+\mathbf{w}^{\intercal}\mathbf{x}_i) \geq 1, \forall i=\overline{1, N}\)</span> là vì khoảng cách từ mọi điểm luôn lớn hơn khoảng cách từ các <em>điểm hỗ trợ</em> tới đường biên phân chia và khoảng cách này bằng 1 vì theo giả định ta đã nhân với hệ số <span class="math notranslate nohighlight">\(k\)</span> vào phương trình đường biên.</p>
<p>Để đơn giản hoá thì bài toán tối ưu <span class="math notranslate nohighlight">\((2)\)</span> có thể nghịch đảo hàm mục tiêu để chuyển sang dạng tương đương:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}
\hat{\mathbf{w}}, \hat{b} &amp; = &amp; \arg \min ||\mathbf{w}||_2^2 \\
\text{subject} &amp; : &amp; y_i(b+\mathbf{w}^{\intercal}\mathbf{x}_i) \geq 1, \forall i=\overline{1, N} ~~~~~~~~~~~~
\tag{3}\end{eqnarray}\end{split}\]</div>
<p>Hàm mục tiêu chúng ta lấy bình phương là để dễ dàng tính đạo hàm. Bài toán tối ưu <span class="math notranslate nohighlight">\((3)\)</span> là một bài toán tối ưu lồi <em>QP</em> khá quen thuộc. Bài toán này có hệ điều kiện ràng buộc tuyến tính và chúng ta có thể giải thông qua hệ điều kiện <em>KKT</em>.</p>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="bai-toan-toi-uu-svm">
<h1>7.3. Bài toán tối ưu SVM<a class="headerlink" href="#bai-toan-toi-uu-svm" title="Permalink to this headline">¶</a></h1>
<div class="section" id="he-dieu-kien-kkt">
<h2>7.3.1. Hệ điều kiện KKT<a class="headerlink" href="#he-dieu-kien-kkt" title="Permalink to this headline">¶</a></h2>
<p>Giả sử chúng ta đang cần giải quyết bài toán tối ưu:</p>
<div class="math notranslate nohighlight">
\[\min_{\mathbf{x}} f(\mathbf{x})\]</div>
<p>Thoả mãn hệ ĐK ràng buộc:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}
h_i(\mathbf{x}) &amp; = &amp; 0 , \forall i=\overline{1, m} \\
g_j(\mathbf{x}) &amp; \leq &amp; 0, \forall j=\overline{1, n} 
\end{eqnarray}\end{split}\]</div>
<p>Bài toán tối ưu có hàm mục tiêu và hệ điều kiện ràng buộc còn được gọi là <em>bài toán gốc</em> (<em>primal problem</em>). Để giải trực tiếp <em>bài toán gốc</em> là tương đối khó nên chúng ta sẽ chuyển sang giải bài toán tối ưu trên <em>hàm đối ngẫu Lagrange</em> (<em>Lagrange Dual Function</em>).</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(\mathbf{x}, \lambda, \nu) = f(\mathbf{x}) + \sum_{i=1}^{m}\lambda_i h_i(\mathbf{x}) + \sum_{j=1}^{n}\nu_j g_j(\mathbf{x})\]</div>
<p>Trong đó <span class="math notranslate nohighlight">\(\lambda_i &gt; 0 ~ \forall i\)</span> và <span class="math notranslate nohighlight">\(\nu_j &gt; 0 ~ \forall j\)</span>, những hệ số này còn được gọi là những <em>nhân tử Lagrange</em> (<em>Lagrange Multipliers</em>).</p>
<p>Bằng cách thiết lập phương trình đạo hàm bậc nhất của hàm Lagrange kết hợp với hệ điều kiện ràng buộc tuyến tính và một số điều kiện khác ta có thể thu được nghiệm của bài toán tối ưu. Hệ điều kiện này được gọi là <em>Karush-Kuhn-Tucker conditions</em> (viết tắt là <em>KKT conditions</em>). Trong tối ưu có rất nhiều các bài toán được giải quyết thông qua hệ điều kiện <em>KKT</em>. Đây là một trong những tiêu chuẩn tìm nghiệm khá hiệu quả và thường được sử dụng trong những bài toán tối ưu có điều kiện ràng buộc. Hệ điều kiện <em>KKT</em> bao gồm các nhóm điều kiện:</p>
<ul class="simple">
<li><p>Stationary: <span class="math notranslate nohighlight">\(\nabla_{\mathbf{x}} f(\mathbf{x}) + \sum_{i=1}^{m}\lambda_i \nabla_{\mathbf{x}} h_i(\mathbf{x}) + \sum_{i=1}^{n} \nu_j \nabla_{\mathbf{x}} g_j(\mathbf{x}) = 0\)</span></p></li>
<li><p>Complenatery slackness: <span class="math notranslate nohighlight">\(\nu_j g_j(\mathbf{x}) = 0, ~~ \forall j\)</span></p></li>
<li><p>Primal Feasibility: <span class="math notranslate nohighlight">\(h_i(\mathbf{x}) = 0, g_j(\mathbf{x}) \leq 0, ~~\forall i, j\)</span>.</p></li>
<li><p>Dual Feasibility: <span class="math notranslate nohighlight">\(\nu_i \geq 0, ~~ \forall i\)</span>.</p></li>
</ul>
<p>Giả sử bài toán là <em>strong duality</em>. Khi đó nghiệm <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span> của <em>hàm đối ngẫu Lagrange</em> cũng là nghiệm của bài toán gốc. Điều kiện cần để hàm mục tiêu đạt được cực trị tại <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span> là đạo hàm bậc nhất bằng 0. Đây chính là điều kiện <em>stationary</em> ở trên.</p>
<p>Không phải khi nào thì ràng buộc dạng bất phương trình đều được thoả mãn. Đối với những bất phương trình không được thoả mãn thì để cực tiểu của hàm Lagrange bằng cực tiểu của bài toán gốc thì <span class="math notranslate nohighlight">\(\nu_j g_j(\mathbf{x}) = 0, ~ \forall j\)</span>. Đây chính là điều kiện <em>complenatery slackness</em>.</p>
<p>Để hàm Lagrange là cận dưới của hàm mục tiêu trong bài toán gốc thì hệ số của những ràng buộc bất phương trình phải thoả mãn <span class="math notranslate nohighlight">\(\nu_i \geq 0\)</span> tương đương với điều kiện <em>dual feasibility</em>.</p>
<p>Ngoài ra, hệ điều kiện ràng buộc phương trình và bất phương trình của bài toán gốc chính cũng cần được thoả mãn. Tức là điều kiện <em>primal feasibility</em> được thoả mãn.</p>
</div>
<div class="section" id="bai-toan-toi-uu-bac-hai-quadratic-optimization">
<h2>7.3.2. Bài toán tối ưu bậc hai (<em>Quadratic Optimization</em>)<a class="headerlink" href="#bai-toan-toi-uu-bac-hai-quadratic-optimization" title="Permalink to this headline">¶</a></h2>
<p><strong>Ví dụ về bài toán tối ưu Quadratic Program</strong></p>
<p><em>Quadratic Program</em> (viết tắt là <em>QP</em>) là một bài toán khá điển hiển hình trong tối ưu hoá và được sử dụng nhiều trong Machine Learning. Đây là dạng bài toán tối ưu xuất hiện trong mô hình SVM. Để hiểu về bài toán tối ưu <em>QP</em> là gì, chúng ta làm quen với một ví dụ đơn giản về tìm cực tiểu như bên dưới:</p>
<div class="math notranslate nohighlight">
\[\min_{x, y} ~~  (5x^2 + 6xy + 2y^2 + 4x+2y+1) \tag{4}\]</div>
<p>Thoả mãn:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}2x + y \geq 4 \\
x+y \geq 3
\end{eqnarray}\end{split}\]</div>
<p>Lời giải cho bài toán khá dễ dàng nhờ khai triển đẳng thức:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}(5x^2+6xy+2y^2 + 4x+2y+1) &amp; = &amp; (4x^2+4xy+y^2 + 4x+2y+1)+(x^2+2xy+y^2) \\
&amp; = &amp; (2x+y+1)^2 + (x+y)^2 \\
&amp; \geq &amp; 5^2+3^2 = 34
\end{eqnarray}\end{split}\]</div>
<p>Tuy nhiên cách giải trên là không tổng quát bởi không phải khi nào chúng ta cũng may mắn tìm được lời giải như trên.</p>
<p><strong>Dạng tổng quát cho tối ưu Quadratic Program</strong></p>
<p>Trong tối ưu thì dạng khái quát cho bài toán trên chính là bài toán tối ưu <em>QP</em> có hàm mục tiêu bậc hai:</p>
<div class="math notranslate nohighlight">
\[ f(\mathbf{x}) = \min_{\mathbf{x}} ~~ \frac{1}{2}\mathbf{x}^{\intercal}\mathbf{A}\mathbf{x} + \mathbf{b}^{\intercal}\mathbf{x} + c\]</div>
<p>Thoả mãn hệ điều kiện ràng buộc tuyến tính:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}
\mathbf{H}\mathbf{x} &amp; = &amp; \mathbf{d} \\
\mathbf{G}\mathbf{x} &amp; \preceq &amp; \mathbf{e}
\end{eqnarray}\end{split}\]</div>
<p>Trong đó ma trận <span class="math notranslate nohighlight">\(\mathbf{A} \in \mathbb{S}^{d}_{+}\)</span> là một ma trận <strong>đối xứng bán xác định dương</strong>. <span class="math notranslate nohighlight">\(\mathbf{H} \in \mathbb{R}^{M\times d}, \mathbf{G} \in \mathbb{R}^{N\times d}\)</span> lần lượt là những ma trận hệ số của hệ phương trình và bất phương trình ràng buộc tuyến tính. <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> là véc tơ đầu vào kích thước là <span class="math notranslate nohighlight">\(d\)</span>. Nếu bạn chưa biết về ma trận bán xác định dương thì đây chính là ma trận mà với mọi véc tơ <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> thì <span class="math notranslate nohighlight">\(\mathbf{x}^{\intercal}\mathbf{A}\mathbf{x} \geq 0, \forall \mathbf{x}\in \mathbb{R}^{d}\)</span>, chúng ta kí hiệu là <span class="math notranslate nohighlight">\(\mathbf{A} \succeq 0\)</span>.</p>
<p>Giả sử <span class="math notranslate nohighlight">\(a_{ij}\)</span> chính là phần tử thuộc dòng thứ <span class="math notranslate nohighlight">\(i\)</span> và cột thứ <span class="math notranslate nohighlight">\(j\)</span> của ma trận <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>. Nếu tinh ý bạn sẽ thấy <span class="math notranslate nohighlight">\(\mathbf{x}^{\intercal}\mathbf{A}\mathbf{x} = \sum_{i=1}^{d}\sum_{j=1}^{d} a_{ij} x_i x_j = a_{ii}x_i^2 + (a_{ij}+a_{ji})x_{ij}\)</span> chính là một đa thức bậc hai giữa tổng các bình phương và tích chéo của biến đầu vào. Thành phần này sẽ khái quát cho <span class="math notranslate nohighlight">\(5x^2+6xy+2y^2\)</span> trong bài toán <span class="math notranslate nohighlight">\((4)\)</span>. Trong khi đó <span class="math notranslate nohighlight">\(\mathbf{b}^{\intercal}\mathbf{x}\)</span> tương ứng với <span class="math notranslate nohighlight">\(4x+2y\)</span> và hằng số <span class="math notranslate nohighlight">\(c\)</span> tương ứng với 1.</p>
<p>Lý do trong bài toán QP chúng ta lại cần <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> là ma trận bán xác định dương là vì khi đó đạo hàm bậc 2 của hàm mục tiêu  <span class="math notranslate nohighlight">\(\nabla_{\mathbf{x}}^2 ~~ [\frac{1}{2}\mathbf{x}^{\intercal}\mathbf{A}\mathbf{x} + \mathbf{b}^{\intercal}\mathbf{x} + c] = (\mathbf{A} + \mathbf{A}^{\intercal}) \succeq 0\)</span> . Do đó hàm mục tiêu là một hàm lồi.</p>
<p>Nếu hàm mục tiêu là lồi và tồn tại một véc tơ <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span> sao cho <span class="math notranslate nohighlight">\(\mathbf{H}\mathbf{x}^*=\mathbf{d}\)</span> và <span class="math notranslate nohighlight">\(\mathbf{G}\mathbf{x}^* \prec \mathbf{e}\)</span> thì ta nói bài toán gốc thoả mãn <em>tiêu chuẩn Slater</em> (<em>Slater’s condition</em>). Khi đó <em>bài toán đối ngẫu</em> là một bài toán <em>strong duality</em> và giá trị cực tiểu của bài toán gốc (<em>primal problem</em>) và bài toán đối ngẫu (<em>dual problem</em>) là bằng nhau. Thông thường thì trong các bài toán tối ưu <em>QP</em> với hệ điều kiện ràng buộc tuyến tính và hàm mục tiêu là một hàm lồi thì <em>tiêu chuẩn Slater</em> thường xuyên xảy ra. Điều đó giúp ta có thể tìm được nghiệm cho bài toán tối ưu thông qua bài toán đối ngẫu.</p>
</div>
<div class="section" id="he-dieu-kien-kkt-doi-voi-bai-toan-quadratic">
<h2>7.3.3. Hệ điều kiện <em>KKT</em> đối với bài toán Quadratic<a class="headerlink" href="#he-dieu-kien-kkt-doi-voi-bai-toan-quadratic" title="Permalink to this headline">¶</a></h2>
<p>Bài toán tối ưu có hàm mục tiêu và hệ điều kiện ràng buộc còn được gọi là <em>bài toán gốc</em> (<em>primal problem</em>). Để giải trực tiếp <em>bài toán gốc</em> là tương đối khó nên chúng ta sẽ chuyển sang giải bài toán tối ưu trên <em>hàm đối ngẫu Lagrange</em> (<em>Lagrange Dual Function</em>).</p>
<div class="math notranslate nohighlight">
\[ g(\lambda, \nu) = \min_{\lambda, \nu} \mathcal{L}(\mathbf{x}, \lambda, \nu)= \frac{1}{2}\mathbf{x}^{\intercal}\mathbf{A}\mathbf{x} + \mathbf{b}^{\intercal}\mathbf{x} + r + \lambda^{\intercal} \mathbf{H}\mathbf{x} + \nu^{\intercal} \mathbf{G}\mathbf{x}\]</div>
<p>Trong đó <span class="math notranslate nohighlight">\(\lambda, \nu\)</span> là những véc tơ hệ số có kích thước lần lượt bằng với số lượng các điều kiện ràng buộc phương trình và bất phương trình và có gía trị lớn hơn hoặc bằng 0. Trong trường hợp bài toán gốc không tồn tại hệ điều kiện bất phương trình thì <em>hàm đối ngẫu Lagrange</em> có dạng:</p>
<div class="math notranslate nohighlight">
\[ g(\lambda) = \min_{\lambda} \mathcal{L}(\mathbf{x}, \lambda)= \frac{1}{2}\mathbf{x}^{\intercal}\mathbf{A}\mathbf{x} + \mathbf{b}^{\intercal}\mathbf{x} + r + \lambda^{\intercal} \mathbf{H}\mathbf{x}\]</div>
<p>Ta dễ dàng nhận thấy ưu điểm của hàm đối ngẫu <span class="math notranslate nohighlight">\(g(\lambda, \nu)\)</span> so với hàm mục tiêu gốc đó là:</p>
<ul class="simple">
<li><p>Là một hàm lồi bất kể <em>hàm mục tiêu gốc</em> có là hàm lồi hay không. Nếu tinh tế ta có thể nhận ra <em>hàm đối ngẫu</em> chính là cận dưới infimum của hàm mục tiêu gốc.</p></li>
<li><p>Trong điều kiện tồn tại <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span> sao cho <span class="math notranslate nohighlight">\(\mathbf{H}\mathbf{x}^{*} = \mathbf{d}\)</span> và <span class="math notranslate nohighlight">\(\mathbf{G}\mathbf{x}^* \prec \mathbf{e}\)</span> thì chúng ta nói tiêu chuẩn <em>Slatter</em> được thoả mãn. Bài toán đối ngẫu khi thoả mãn tiêu chuẩn <em>Slatter</em> sẽ là một bài toán <em>đối ngẫu mạnh</em> (<em>strong duality</em>). Khi đó hệ điều kiện KKT là điều kiện cần và cũng là điều kiện đủ và giá trị cực tiểu <span class="math notranslate nohighlight">\(f^* = g^*\)</span>.</p></li>
</ul>
<p>Bài toán đối ngẫu có thể được giải thông qua hệ điều kiện <em>KKT</em>. Đối với bài toán tối ưu <em>QP</em> không tồn tại hệ điều kiện ràng buộc bất phương trình thì có hệ điều kiện <em>KKT</em> như bên dưới:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
\mathbf{A} &amp; \mathbf{H}^{\intercal} \\
\mathbf{H} &amp; \mathbf{0}
\end{bmatrix}\begin{bmatrix}
\mathbf{x} \\
\mathbf{\lambda}
\end{bmatrix} = \begin{bmatrix}
-\mathbf{b} \\
\mathbf{d}
\end{bmatrix}\end{split}\]</div>
<p>Dòng thứ nhất của phương trình ma trận trên sẽ tương ứng với đạo hàm bậc nhất Lagrange bằng 0:</p>
<div class="math notranslate nohighlight">
\[\mathbf{A}\mathbf{x}+\mathbf{H}^{\intercal}\lambda = -\mathbf{b}\]</div>
<p>Dòng thứ 2 chính là phương trình ràng buộc.</p>
<div class="math notranslate nohighlight">
\[\mathbf{H}\mathbf{x} = \mathbf{d}\]</div>
<p>Để giải bài toán tối ưu QP có thể sử dụng package <a class="reference external" href="https://pypi.org/project/cvxopt/">cvxopt</a> trong python. Đây là một package chuyên biệt giúp giải quyết các bài toán tối ưu lồi.</p>
</div>
<div class="section" id="bai-toan-doi-ngau-svm">
<h2>7.3.4. Bài toán đối ngẫu SVM<a class="headerlink" href="#bai-toan-doi-ngau-svm" title="Permalink to this headline">¶</a></h2>
<p>Bài toán tối ưu <span class="math notranslate nohighlight">\((3)\)</span> chính là một bài toán QP tương ứng với:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{A}\)</span> là ma trận đơn vị.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{b}\)</span> là véc tơ 0.</p></li>
<li><p>Ma trận ràng buộc <span class="math notranslate nohighlight">\(\mathbf{G} \in \mathbb{R}^{N \times d}\)</span> có các dòng chính là các điều kiện ràng buộc <span class="math notranslate nohighlight">\(y_i(b+\mathbf{w}^{\intercal}\mathbf{x})\geq 1\)</span>.</p></li>
</ul>
<p>Hàm đối ngẫu trong bài toán tối ưu ở <span class="math notranslate nohighlight">\((3)\)</span>:</p>
<div class="math notranslate nohighlight">
\[g(\lambda) = \min_{\mathbf{w}, b, \lambda} \mathcal{L}(\mathbf{w}, b, \lambda) = \frac{1}{2} ||\mathbf{w}||_2^2 + \sum_{i=1}^N \lambda_i(1 - y_i(\mathbf{w}^{\intercal}\mathbf{x}_i + b) ) \tag{5}
\]</div>
<p>Nghiệm tối ưu của hàm Lagrange <span class="math notranslate nohighlight">\((5)\)</span> có thể được tìm thông qua đạo hàm bậc nhất:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
\frac{\partial \mathcal{L}(\mathbf{w}, b, \lambda)}{\partial \mathbf{w}} &amp;=&amp; \mathbf{w} - \sum_{i=1}^N \lambda_i y_i \mathbf{x}_i = 0 \Rightarrow \mathbf{w} = \sum_{i=1}^N \lambda_i y_i \mathbf{x}_i  \tag{6}\\
\frac{\partial \mathcal{L}(\mathbf{w}, b, \lambda)}{\partial b} &amp;=&amp; 
-\sum_{i=1}^N \lambda_iy_i = 0 \tag{7} \\
\frac{\partial \mathcal{L}(\mathbf{w}, b, \lambda)}{\partial \lambda} &amp; = &amp; \sum_{i=1}^N  1-y_i(\mathbf{w}^{\intercal}\mathbf{x}_i + b) = 0 \tag{8}
\end{eqnarray}
\end{split}\]</div>
<p>Bằng một số phép biến đổi đơn giản trên hàm đối ngẫu ta thu được một biểu thức ngắn gọn.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
g(\lambda) &amp; = &amp; \frac{1}{2} ||\mathbf{w}||_2^2 + \sum_{i=1}^N\lambda_i - \mathbf{w}^{\intercal} \underbrace{\sum_{i=1}^{N} \lambda_iy_i \mathbf{x}_i}_{\mathbf{w}} - b \underbrace{\sum_{i=1}^N \lambda_i y_i}_{0} \\
&amp; = &amp; \sum_{i=1}^N\lambda_i - \frac{1}{2} ||\mathbf{w}||_2^2 \\
&amp; = &amp; \sum_{i=1}^N\lambda_i - \frac{1}{2} \sum_{i=1}^N \lambda_i y_i \mathbf{x}_i^{\intercal} \sum_{i=1}^N \lambda_i y_i \mathbf{x}_i   \\
&amp; = &amp; \sum_{i=1}^N \lambda_i - \frac{1}{2} \sum_{i=1}^N \sum_{j=1}^N \lambda_i \lambda_j y_i y_j \mathbf{x}_i^{\intercal} \mathbf{x}_j
\end{eqnarray}
\end{split}\]</div>
<p>Theo hệ điều kiện <em>KKT</em> thì giá trị cực tiểu của hàm <span class="math notranslate nohighlight">\(g(\lambda)\)</span> đạt được khi <span class="math notranslate nohighlight">\(\sum_{i=1}^N \lambda_i(1 - y_i(\mathbf{w}^{\intercal}\mathbf{x}_i + b) ) = 0\)</span>. Đẳng thức trên đạt được khi <span class="math notranslate nohighlight">\(\lambda_i = 0\)</span> hoặc <span class="math notranslate nohighlight">\(1-y_i(\mathbf{w}^{\intercal}\mathbf{x}_i + b) = 0, ~ \forall i=\overline{1,N}\)</span>. Trên thực tế thì véc tơ <span class="math notranslate nohighlight">\(\lambda\)</span> là một véc tơ thưa có hầu hết các chiều đều bằng 0. Đối với những điểm dữ liệu tương ứng với <span class="math notranslate nohighlight">\(\lambda_i &gt; 0\)</span> thì phương trình <span class="math notranslate nohighlight">\(1 - y_i(\mathbf{w}^{\intercal}\mathbf{x}_i + b) = 0\)</span> sẽ được thoả mãn và tập hợp những điểm này khi đó sẽ nằm trên <em>mép của lề</em>. Tập hợp những điểm này còn gọi là <em>tập hỗ trợ</em> (<em>support vector</em>) và được kí hiệu là <span class="math notranslate nohighlight">\(\mathcal{S}\)</span>.</p>
<p>Phương trình <span class="math notranslate nohighlight">\((6)\)</span> cho chúng ta biết rằng tập hợp các điểm thuộc tập hỗ trợ có thể giúp ta tính ra <span class="math notranslate nohighlight">\(\mathbf{w}\)</span>. Thật vậy:</p>
<div class="math notranslate nohighlight">
\[\mathbf{w} = \sum_{i=1}^{N} \lambda_iy_i\mathbf{x}_i = \sum_{i=1, \lambda_i \neq 0}^{N} \lambda_iy_i\mathbf{x}_i = \sum_{(\mathbf{x}_i, y_i) \in \mathcal{S}} \lambda_i y_i\mathbf{x}_i\]</div>
<p>Ngoài ra đối với toàn bộ các điểm thuộc tập hỗ trợ thì:</p>
<div class="math notranslate nohighlight">
\[1-y_i(\mathbf{w}^{\intercal}\mathbf{x}+b) = 0 \leftrightarrow y_i(y_i-\mathbf{w}^{\intercal}\mathbf{x}_i-b) = 0 \leftrightarrow y_i - \mathbf{w}^{\intercal}\mathbf{x}_i-b=0\]</div>
<p>Như vậy sau khi tính được <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> thì ta suy ra giá trị của <span class="math notranslate nohighlight">\(b\)</span>:</p>
<div class="math notranslate nohighlight">
\[b = \frac{1}{|\mathcal{S}|}\sum_{(\mathbf{x}_i, y_i) \in \mathcal{S}}(y_i-\mathbf{w}^{\intercal}\mathbf{x}_i)\]</div>
</div>
<div class="section" id="du-bao-nhan">
<h2>7.3.5. Dự báo nhãn<a class="headerlink" href="#du-bao-nhan" title="Permalink to this headline">¶</a></h2>
<p>Nhãn của một quan sát trong mô hình <em>SVM</em> sẽ phụ thuộc vào dấu của đường biên:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{eqnarray} h_{\mathbf{w}, b}(\mathbf{x}_i) &amp; = &amp; b + \mathbf{w}^{\intercal}\mathbf{x}_i \\
&amp; = &amp; b + (~ \sum_{(\mathbf{x}_j, y_j) \in \mathcal{S}}\lambda_jy_j \mathbf{x}_j^{\intercal} ~)\mathbf{x}_i \\
&amp; = &amp; b + \sum_{(\mathbf{x}_j, y_j) \in \mathcal{S}} \lambda_j y_j \mathbf{x}_{j}^{\intercal} \mathbf{x}_i \\
\end{eqnarray}\end{split}\]</div>
<p>Trong trường hợp <span class="math notranslate nohighlight">\(h_{\mathbf{w}, b}(\mathbf{x}_i) &gt; 0\)</span> thì điểm được dự báo nhãn <span class="math notranslate nohighlight">\(1\)</span> và trái lại là nhãn <span class="math notranslate nohighlight">\(-1\)</span>.</p>
<p>Từ dòng thứ <span class="math notranslate nohighlight">\(1\)</span> sang dòng thứ <span class="math notranslate nohighlight">\(2\)</span> là vì giá trị <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> được tính trực tiếp từ <em>tập hỗ trợ</em>. Công thức trên cho thấy thay vì phải xác định nhãn dựa trên các hệ số của phương trình đường biên <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> thì chúng ta có thể thông qua các điểm thuộc <em>tập hỗ trợ</em>.</p>
</div>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="sorf-margin-classification">
<h1>7.4. Sorf Margin Classification<a class="headerlink" href="#sorf-margin-classification" title="Permalink to this headline">¶</a></h1>
<div class="section" id="so-sanh-giua-le-cung-hard-margin-va-le-mem-soft-margin">
<h2>7.4.1. So sánh giữa lề cứng (<em>hard margin</em>) và lề mềm (<em>soft margin</em>)<a class="headerlink" href="#so-sanh-giua-le-cung-hard-margin-va-le-mem-soft-margin" title="Permalink to this headline">¶</a></h2>
<p>Đường biên phân chia của thuật toán SVM sẽ chịu ảnh hưởng bởi những điểm thuộc tập hỗ trợ <span class="math notranslate nohighlight">\(\mathcal{S}\)</span>. Trong trường hợp đường biên phân chia <strong>đúng mọi điểm điểm dữ liệu</strong> thì được gọi là bài toán phân loại theo đường biên cứng (<em>hard margin classification</em>). Tuy nhiên đường biên cứng tỏ ra hạn chế nếu tồn tại dữ liệu ngoại lai (<em>outlier</em>). Chúng ta cùng phân tích hạn chế này ở hình minh hoạ bên dưới.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">svm</span>

<span class="c1"># we create 40 separable points</span>
<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">cluster_std</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">idx_cls_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">idx_cls_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">id_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># fit the model</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="c1"># Adjust outlier</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">X</span><span class="p">[</span><span class="n">id_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> 

    <span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># get the separating hyperplane</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">coef_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">yy</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">xx</span> <span class="o">-</span> <span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">intercept_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># plot the parallels to the separating hyperplane that pass through the</span>
    <span class="c1"># support vectors (margin away from hyperplane in direction</span>
    <span class="c1"># perpendicular to hyperplane). This is sqrt(1+a^2) away vertically in</span>
    <span class="c1"># 2-d.</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">coef_</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">yy_down</span> <span class="o">=</span> <span class="n">yy</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">margin</span>
    <span class="n">yy_up</span> <span class="o">=</span> <span class="n">yy</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">margin</span>
    <span class="c1"># plot the line, the points, and the nearest vectors to the plane</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy_down</span><span class="p">,</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy_up</span><span class="p">,</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>

    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">support_vectors_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">clf</span><span class="o">.</span><span class="n">support_vectors_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
                <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;RdBu&#39;</span><span class="p">))</span>
    

    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">idx_cls_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">idx_cls_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">idx_cls_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">idx_cls_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="n">YY</span><span class="p">,</span> <span class="n">XX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">)</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">XX</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">YY</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">XX</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.5</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="c1"># Put the result into a contour plot</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
           <span class="n">linestyles</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;--&#39;</span><span class="p">])</span>

    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Hard Margin SVM&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Hard Margin SVM with Outlier&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/SVM_21_0.png" src="../_images/SVM_21_0.png" />
</div>
</div>
<!-- ![](https://imgur.com/8B67kPe.png) -->
<p><strong>Hình 3:</strong> Hình bên trái là <em>phân loại đường biên cứng</em> (<em>Hard margin SVM</em>) đối với tập dữ liệu thông thường. Hình bên phải là <em>phân loại đường biên cứng</em> đối với dữ liệu chứa điểm ngoại lai (là điểm hình sao được khoanh tròn). Phương pháp <em>phân loại đường biên cứng</em> buộc phải phân loại đúng mọi điểm dữ liệu, bao gồm cả điểm ngoại lai. Điều này khiến cho đường biên phân chia bị thu hẹp lại. Khi đó qui luật phân chia sẽ không còn giữ được yếu tố tổng quát và dẫn tới hiện tượng quá khớp (<em>overfitting</em>). Kết quả dự báo trên tập <em>kiểm tra</em> khi đó sẽ kém hơn so với tập <em>huấn luyện</em>.</p>
<p>Để khắc phục hạn chế của <em>phân loại đường biên cứng</em>, kỹ thuật <em>phân loại đường biên mềm</em> (<em>Sorf Margin Classification</em>) chấp nhận đánh đổi để mở rộng lề và cho phép phân loại sai các điểm ngoại lai. Cụ thể hơn, thuật toán sẽ chấp nhận một số điểm bị rơi vào vùng của lề (vùng nằm giữa hai đường nét đứt, vùng này còn được gọi là <em>vùng không an toàn</em>) nhưng trái lại, chi phí cơ hội của sự đánh đổi đó là độ rộng lề lớn hơn. Đường biên phân chia được tạo ra từ kỹ thuật này thường nắm được tính <em>tổng quát</em> và hạn chế hiện tượng <em>quá khớp</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">svm</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="c1"># fit the modelf</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">penalty</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([(</span><span class="s1">&#39;hard margin&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;soft margin&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)]):</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="o">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">penalty</span><span class="p">)</span>
    <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># get the separating hyperplane</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">coef_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">yy</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">xx</span> <span class="o">-</span> <span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">intercept_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># plot the parallels to the separating hyperplane that pass through the</span>
    <span class="c1"># support vectors (margin away from hyperplane in direction</span>
    <span class="c1"># perpendicular to hyperplane). This is sqrt(1+a^2) away vertically in</span>
    <span class="c1"># 2-d.</span>
    <span class="n">margin</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">coef_</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">yy_down</span> <span class="o">=</span> <span class="n">yy</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">margin</span>
    <span class="n">yy_up</span> <span class="o">=</span> <span class="n">yy</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">margin</span>

    <span class="c1"># plot the line, the points, and the nearest vectors to the plane</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy_down</span><span class="p">,</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy_up</span><span class="p">,</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>

    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">support_vectors_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">clf</span><span class="o">.</span><span class="n">support_vectors_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
                <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;RdBu&#39;</span><span class="p">))</span>
    

    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">idx_cls_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">idx_cls_0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">idx_cls_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">idx_cls_1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="n">YY</span><span class="p">,</span> <span class="n">XX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">)</span>
    <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">XX</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">YY</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">decision_function</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">XX</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.5</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="c1"># Put the result into a contour plot</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
           <span class="n">linestyles</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;--&#39;</span><span class="p">])</span>

    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Hard Margin SVM, C=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">penalty</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Soft Margin SVM, C=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">penalty</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/SVM_23_0.png" src="../_images/SVM_23_0.png" />
</div>
</div>
<p><strong>Hình 4:</strong> Phân loại biên cứng (bên trái) và phân loại biên mềm (bên phải) trong SVM. Chúng ta nhận thấy đối với đường biên mềm thì SVM chấp nhận một số điểm rơi vào <em>vùng không an toàn</em> để nhằm tạo ra một đường biên phân chia tổng quát hơn. Trong khi phân loại theo đường biên cứng thì không chấp nhận những điểm dữ liệu bị lấn sang <em>vùng không an toàn</em>.</p>
</div>
<div class="section" id="suy-xet-lai-ham-chi-phi-cho-phan-loai-duong-bien-mem-svm">
<h2>7.4.2. Suy xét lại hàm chi phí cho phân loại đường biên mềm SVM<a class="headerlink" href="#suy-xet-lai-ham-chi-phi-cho-phan-loai-duong-bien-mem-svm" title="Permalink to this headline">¶</a></h2>
<p>Ý tưởng của <em>phân loại đường biên mềm</em> là mở rộng lề và chấp nhận hi sinh một số điểm bị rơi vào <em>vùng không an toàn</em> để tạo ra một đường biên phân chia tổng quát hơn. Nhưng chúng ta không thể mở rộng lề ra vô cùng vì như vậy có nhiều điểm bị rơi vào <em>vùng không an toàn</em> hơn và dẫn tới sự hi sinh là quá lớn. Quá trình mở rộng lề sẽ bị kìm hãm sao cho đối với những điểm bị rơi vào <em>vùng không an toàn</em> thì tổng khoảng cách của chúng tới <em>mép của lề</em> về phía mặt phẳng của nhãn ground truth của chúng là nhỏ nhất. Khoảng cách này được thể hiện qua biến slack (ký hiệu <span class="math notranslate nohighlight">\(\xi_n\)</span>):</p>
<div class="math notranslate nohighlight">
\[d(Z_i, H) \triangleq \xi_i = |b+\mathbf{w}^{\intercal}\mathbf{x}_i-y_i|\]</div>
<p><img alt="" src="https://i.imgur.com/8QxDuSf.jpeg" /></p>
<p><strong>Hình 5:</strong> Khoảng cách từ một điểm tới <em>mép của lề</em>. Mặt dương bên trái là các điểm dấu <code class="docutils literal notranslate"><span class="pre">x</span></code> và bên phải là các điểm hình vuông. Xét 3 trường hợp của các điểm dấu <code class="docutils literal notranslate"><span class="pre">x</span></code> thuộc mặt dương. Điểm <span class="math notranslate nohighlight">\(Z_1\)</span> được phân về đúng mặt phân chia và nằm ngoài đường biên nên không bị phạt, điểm này có khoảng cách <span class="math notranslate nohighlight">\(\xi_1=0\)</span>. Điểm <span class="math notranslate nohighlight">\(Z_2\)</span> tương ứng với <span class="math notranslate nohighlight">\(\xi_2 &gt; 1\)</span>, đây là những điểm vượt qua đường biên và bị phân loại sai. Điểm này có khoảng cách tới mép của lề như thể hiện trên hình là <span class="math notranslate nohighlight">\(\xi_2 = \mathbf{w}^{\intercal}\mathbf{x}+b-1\)</span>. Điểm <span class="math notranslate nohighlight">\(Z_3\)</span> tương ứng với <span class="math notranslate nohighlight">\(0 \leq \xi_3 \leq 1\)</span>, đây là những điểm chưa vượt qua đường biên sang phía bên kia. Do đó dù rơi vào <em>vùng không an toàn</em> nhưng vẫn được phân loại đúng nhãn. Khoảng cách của chúng tới mép của lề <span class="math notranslate nohighlight">\(\xi_3 = 1-\mathbf{w}^{\intercal}\mathbf{x}-b\)</span>. Một cách tổng quát, nếu một điểm rơi vào <em>vùng không an toàn</em> thì khoảng cách xâm lấn của chúng là <span class="math notranslate nohighlight">\(\xi_n = |b+\mathbf{w}^{\intercal}\mathbf{x}_i-y_i|\)</span>.</p>
<p><strong>Bài tập:</strong> Chứng minh công thức khoảng cách xâm lấn <span class="math notranslate nohighlight">\(\xi_n = |b+\mathbf{w}^{\intercal}\mathbf{x}_i-y_i|\)</span> cho cả hai trường hợp <span class="math notranslate nohighlight">\(y_i = 1\)</span> và <span class="math notranslate nohighlight">\(y_i = -1\)</span>.</p>
<p>Trong hàm mất mát tồn tại sự đánh đổi giữa sự hi sinh các điểm rơi vào <em>vùng không an toàn</em> và sự mở rộng của lề. Nếu muốn hi sinh ít điểm bị rơi vào <em>vùng không an toàn</em> hơn thì chúng ta cần lề phải hẹp hơn. Nhưng lề hẹp đồng nghĩa với mức độ khái quát của đường biên phân chia thấp như sự so so sánh đường biên cứng và mềm đã phân tích ở hình 2. Như vậy hàm mất mát là sự dung hoà giữa hai yếu tố tối thiểu hoá sự hi sinh các điểm và tối đa hoá khoảng cách:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}
\hat{\mathbf{w}}, \hat{b} &amp; = &amp; \arg \min ~[~||\mathbf{w}||_2^2 + C \sum_{i=1}^{N} |b+\mathbf{w}^{\intercal}\mathbf{x}_i-y_i|~] \\
&amp; = &amp; \arg \min ~[~||\mathbf{w}||_2^2 + C \sum_{i=1}^{N} \xi_i~]\\
\text{subject} &amp; : &amp; y_i(b+\mathbf{w}^{\intercal}\mathbf{x}_i) + \xi_i - 1 \geq 0, \xi_i \geq 0 ~ \forall i=\overline{1, N} \tag{9}
\end{eqnarray}\end{split}\]</div>
<p>Ràng buộc <span class="math notranslate nohighlight">\(y_i(b+\mathbf{w}^{\intercal}\mathbf{x}_i) + \xi_i - 1 \geq 0 \leftrightarrow \xi_i \geq 1-y_i(b+\mathbf{w}^{\intercal}\mathbf{x}_i)\)</span> có ý nghĩa rằng chúng ta chỉ cho phép các điểm bị lấn sang <em>vùng không an toàn</em> một ngưỡng tối đa <span class="math notranslate nohighlight">\(\xi_i\)</span>. Ngoài ra trong bài toán tối ưu cần có thêm điều kiện ràng buộc <span class="math notranslate nohighlight">\(\xi_i \geq 0\)</span>.</p>
<p>Hệ số <span class="math notranslate nohighlight">\(C\)</span> là một hệ số rất quan trọng thể hiện tỷ lệ đánh đối giữa sự mở rộng lề và và sự hi sinh. Một hệ số <span class="math notranslate nohighlight">\(C\)</span> lớn thì ảnh hường của <span class="math notranslate nohighlight">\(||\mathbf{w}||_2^2\)</span> sẽ không đáng kể lên giá trị của hàm mất mát. Giá trị của hàm mất mát chủ yếu đến từ tổng khoảng cách xâm lấn. Tối thiểu hàm mất mát đồng nghĩa với cần hạn chế bớt mức độ xâm lấn. Điều này dẫn tới độ rộng lề nhỏ hơn. Trong trường hợp tập dữ liệu là <em>phân tuyến</em> thì tồn tại một đường biên phân chia đúng mọi điểm dữ liệu. Như vậy <span class="math notranslate nohighlight">\(\sum_{i=1}^N \xi_i = 0\)</span> và ta thu được bài toán <em>phân loại đường biên cứng</em> (<em>hard margin SVM</em>).</p>
<p>Trái lại trường hợp <span class="math notranslate nohighlight">\(C\)</span> nhỏ dẫn tới <span class="math notranslate nohighlight">\(||\mathbf{w}||_{2}^{2}\)</span> nhỏ. Do đó độ rộng lề là lớn hơn. Điều đó đồng nghĩa với mức độ xâm lấn cũng lớn theo. Sẽ tồn tại một số điểm xâm lấn tương ứng với <span class="math notranslate nohighlight">\(\xi_i &gt; 0\)</span> và trường hợp này tương ứng với bài toán <em>phân loại đường biên mềm</em> (<em>soft margin SVM</em>).</p>
<p>Bài toán tối ưu <span class="math notranslate nohighlight">\((9)\)</span> là một bài toán tối ưu QP và có thể giải thông qua hệ điều kiện <em>KKT</em>. Bài toán này có <em>hàm đối ngẫu Lagrange</em>:</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(\mathbf{w}, b, \xi, \lambda, \nu) = \frac{1}{2}{||\mathbf{w}||_2^2} + C \sum_{i=1}^N \xi_i + \sum_{i=1}^N \lambda_i ( 1 - \xi_i - y_i(\mathbf{w}^{\intercal}\mathbf{x}_i + b)) - \sum_{i=1}^N \nu_i \xi_i
\]</div>
<p>Trong đó <span class="math notranslate nohighlight">\(\lambda_i, \nu_i &gt; 0, ~~ \forall i=\overline{1,N}\)</span></p>
<p>Điều kiện cần của cực trị theo đạo hàm bậc nhất của hàm Lagrange:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{eqnarray}
\frac{\partial \mathcal{L}(\mathbf{w}, b, \xi, \lambda, \nu)}{\partial \mathbf{w}} &amp;=&amp; \mathbf{w} - \sum_{i=1}^N \lambda_i y_i \mathbf{x}_i = 0 \Rightarrow \mathbf{w} = \sum_{i=1}^N \lambda_i y_i \mathbf{x}_i \tag{10}\\ 
\frac{\partial \mathcal{L}(\mathbf{w}, b, \xi, \lambda, \nu)}{\partial b} &amp;=&amp; 
-\sum_{i=1}^N \lambda_iy_i = 0 \tag{11}\\
\frac{\partial \mathcal{L}(\mathbf{w}, b, \xi, \lambda, \nu)}{\partial \xi_i} &amp; = &amp; C - \lambda_i-\nu_i = 0 \tag{12} \\
\end{eqnarray}
\end{split}\]</div>
<p>Đẳng thức <span class="math notranslate nohighlight">\((10)\)</span> và <span class="math notranslate nohighlight">\((11)\)</span> cho thấy chúng ta có thể suy ra các hệ số của phương trình đường biên thông qua những điểm có <span class="math notranslate nohighlight">\(\lambda_i &gt; 0\)</span>. Đây là những điểm nằm trên đường biên hoặc những điểm bị lấn vào lề.</p>
<p>Từ đẳng thức <span class="math notranslate nohighlight">\((12)\)</span> ta suy ra <span class="math notranslate nohighlight">\(\nu_i = C-\lambda_i \geq 0\)</span>. Như vậy trong mọi trường hợp thì <span class="math notranslate nohighlight">\(\lambda_i \leq C\)</span>.</p>
<p>Theo điều kiện <em>complementary slackness</em> của tiêu chuẩn <em>KKT</em> thì <span class="math notranslate nohighlight">\(\lambda_i(1-\xi_i-y_i(\mathbf{w}^{\intercal}\mathbf{x}_i+b)) = 0\)</span> và <span class="math notranslate nohighlight">\(\nu_i\xi_i = 0\)</span>.</p>
<ul class="simple">
<li><p>Trong trường hợp <span class="math notranslate nohighlight">\(\lambda_i = 0\)</span> thì <span class="math notranslate nohighlight">\(\nu_i = C-\lambda_i = C &gt; 0\)</span>. Như vậy để <span class="math notranslate nohighlight">\(\nu_i\xi_i = 0\)</span> thì <span class="math notranslate nohighlight">\(\xi_i = 0\)</span>. Các điểm dữ liệu nằm trong <em>vùng an toàn</em> và không bị phạt.</p></li>
<li><p>Trong trường hợp <span class="math notranslate nohighlight">\(0 &lt; \lambda_i \leq C\)</span> thì <span class="math notranslate nohighlight">\(\nu_i = C - \lambda_i&gt; 0\)</span>. Để <span class="math notranslate nohighlight">\(\nu_i \xi_i = 0\)</span> thì <span class="math notranslate nohighlight">\(\xi_i = 0\)</span>. Mặt khác <span class="math notranslate nohighlight">\(\lambda_i(1-\xi_i-y_i(\mathbf{w}^{\intercal}\mathbf{x}_i+b)) = 0 \leftrightarrow 1-\xi_i-y_i(\mathbf{w}^{\intercal}\mathbf{x}_i+b) = 0\)</span>. Thế <span class="math notranslate nohighlight">\(\xi_i = 0\)</span> ta thu được: <span class="math notranslate nohighlight">\(1-y_i(\mathbf{w}^{\intercal}\mathbf{x}_i+b) = 0\)</span>. Đây là những điểm trong <em>tập hỗ trợ</em> giúp tạo thành đường biên phân chia.</p></li>
<li><p>Trong trường hợp <span class="math notranslate nohighlight">\(\lambda_i = C\)</span> thì <span class="math notranslate nohighlight">\(\nu_i = C-\lambda_i = 0\)</span>. Như vậy giá trị <span class="math notranslate nohighlight">\(\xi_i\)</span> không nhất thiết phải bằng 0. Có thể tồn tại <span class="math notranslate nohighlight">\(\xi_i &gt; 0\)</span> tương ứng với những điểm bị hi sinh.</p></li>
</ul>
<p>Khi tiến hành tinh chỉnh mô hình, chúng ta quan tâm nhiều tới hệ số <span class="math notranslate nohighlight">\(C\)</span> vì nó ảnh hưởng trực tiếp tới hình dạng của đường biên và kiểm soát hiện tượng <em>quá khớp</em>.</p>
<p>Trong python để <em>phân loại đường biên mềm</em> thì chúng ta có thể sử dụng module <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html">sklearn.svm.SVC</a> hoặc <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.LinearSVC.html">sklearn.svm.LinearSVC</a> thông qua việc thiết lập đối số <span class="math notranslate nohighlight">\(C\)</span> thấp. Ở ví dụ hình 2 bạn cũng có thể thấy với <code class="docutils literal notranslate"><span class="pre">Soft</span> <span class="pre">Margin</span> <span class="pre">SVM</span></code> thì chúng ta để <span class="math notranslate nohighlight">\(C=0.05\)</span></p>
<p>Ngoài ra <code class="docutils literal notranslate"><span class="pre">LinearSVC</span></code> cũng tương ứng với <code class="docutils literal notranslate"><span class="pre">SVC</span></code> với cấu hình <code class="docutils literal notranslate"><span class="pre">kernel='linear'</span></code> (tức là sử dụng kernel tuyến tính mà ta sẽ tìm hiểu bên dưới), module <code class="docutils literal notranslate"><span class="pre">LinearSVC</span></code> có tốc độ nhanh hơn so với <code class="docutils literal notranslate"><span class="pre">SVC</span></code> nên được khuyến nghị hồi qui với những tập dữ liệu lớn. Khi huấn luyện với bộ dữ liệu kích thước nhỏ (khoảng vài ngàn quan sát) thì có thể sử dụng SVC. Ưu điểm của <code class="docutils literal notranslate"><span class="pre">SVC</span></code> đó là chúng ta được phép lựa chọn đa dạng các phép biến đổi kernel. Trong khi <code class="docutils literal notranslate"><span class="pre">LinearSVC</span></code> là phương pháp dựa trên kernel <code class="docutils literal notranslate"><span class="pre">linear</span></code>. Trong <code class="docutils literal notranslate"><span class="pre">LinearSVC</span></code> cho phép chúng ta lựa chọn được loại hàm điều chuẩn thông qua đối số <code class="docutils literal notranslate"><span class="pre">penalty</span></code> và dạng của hàm mất mát thông qua đối số <code class="docutils literal notranslate"><span class="pre">loss</span></code>.</p>
<p>Tiếp theo chúng ta sẽ cùng tìm hiểu về <em>tạo lập đặc trưng</em> (<em>feature engineering</em>) trong SVM.</p>
</div>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="ky-thuat-tao-dac-trung">
<h1>7.5. Kỹ thuật tạo đặc trưng<a class="headerlink" href="#ky-thuat-tao-dac-trung" title="Permalink to this headline">¶</a></h1>
<p>Trong thuật toán <em>phân loại đường biên mềm</em> SVM chúng ta sẽ quyết định nhãn cho một điểm dữ liệu dựa vào đường biên phân loại như sau:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
y = \left\{
\begin{matrix}
~1 &amp; \text{ if } b + \mathbf{w}^{\intercal}\mathbf{x}_i \geq 0 \\
-1 &amp; \text{ if otherwise}
\end{matrix}
\right.\end{split}\end{split}\]</div>
<p>Đường biên phân chia <span class="math notranslate nohighlight">\(b + \mathbf{w}^{\intercal}\mathbf{x}_i\)</span> sẽ là một đường thẳng trong không gian hai chiều và trong không gian 3 chiều đường biên này là một mặt phẳng (<em>plane</em>). Trong không gian nhiều hơn 3 chiều thì chúng ta gọi đường biên phân chia của SVM là một siêu phẳng (<em>hyperplane</em>). Hình dạng của những đường biên phân chia tuyến tính này là tương đối đơn giản nên để gia tăng hiệu quả của mô hình SVM thì chúng ta sẽ sử dụng các hàm biến đổi phi tuyến trên các biến đầu vào.</p>
<p>Một cách khái quát, giả định các hàm <span class="math notranslate nohighlight">\(\varphi_1(.), \varphi_2(.), \dots , \varphi_n(.)\)</span> là các <em>hàm biến đổi phi tuyến</em> (<em>non-linear transformation function</em>). Khi đó phương trình đường biên sẽ được chuyển sang phương trình của <em>hàm biến đổi phi tuyến</em> như sau:</p>
<div class="math notranslate nohighlight">
\[h(\mathbf{x}, \mathbf{w}) = b + w_1 \varphi_1(\mathbf{x}) + w_2 \varphi_1(\mathbf{x}) + \dots + w_n \varphi_n(\mathbf{x}) \tag{5}\]</div>
<p>Những biến đổi phi tuyến giúp chúng ta tạo ra được những đường biên phân loại phức tạp hơn và giúp cải thiện độ chính xác của mô hình. Có một số dạng <em>hàm biến đổi phi tuyến</em> là khá tường minh và dễ áp dụng như hàm <em>đa thức (polynormial)</em> và hàm <em>Gaussian RBF</em> (sẽ tìm hiểu bên dưới).</p>
<div class="section" id="dac-trung-da-thuc-polynormial-features">
<h2>7.5.1. Đặc trưng đa thức (<em>Polynormial Features</em>)<a class="headerlink" href="#dac-trung-da-thuc-polynormial-features" title="Permalink to this headline">¶</a></h2>
<p>Trong hầu hết các bài toán machine learning, khi muốn gia tăng độ chính xác cho mô hình thì chúng ta thường sử dụng kỹ thuật tạo lập <em>đặc trưng đa thức</em> (<em>Polynormial Features</em>). Kỹ thuật này sẽ thêm những biến bậc cao (chẳng hạn như <span class="math notranslate nohighlight">\(x_1^2, x_1^3\)</span>) và biến tích chéo (chẳng hạn <span class="math notranslate nohighlight">\(x_1 x_2, x_1^2 x_2\)</span>) vào mô hình để gia tăng khả năng biểu diễn cho mô hình phân loại. Kỹ thuật này đã được giới thiệu và áp dụng trong các mô hình <em>hồi qui tuyến tính</em>, <em>hồi qui Logistic</em> ở những chương trước.</p>
</div>
<div class="section" id="dac-trung-tuong-dong-gaussian-rbf">
<h2>7.5.2. Đặc trưng tương đồng Gaussian RBF<a class="headerlink" href="#dac-trung-tuong-dong-gaussian-rbf" title="Permalink to this headline">¶</a></h2>
<p>Bên cạnh phương pháp tạo lập <em>đặc trưng đa thức</em> (<em>Polynormial Features</em>) chúng ta còn sử dụng một phương pháp tạo lập đặc trưng tương đồng dựa trên hàm <em>Gaussian RBF</em>. Trên phân phối của tập dữ liệu chúng ta xác định một tập hợp các điểm landmarks. Landmarks ở đây được hiểu như là những điểm tiêu biểu đại diện cho các nhãn.</p>
<p>Một hàm độ đo <em>Gaussian RBF</em> (RBF là viết tắt của <em>radial basis function</em>) về bản chất là khoảng cách hoặc mức độ tương đồng giữa một điểm dữ liệu <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> bất kỳ với một điểm landmark <span class="math notranslate nohighlight">\(l\)</span> có dạng như sau:</p>
<div class="math notranslate nohighlight">
\[\varphi(\mathbf{x}, l) = \exp(-\gamma||\mathbf{x}-l||_2^2)\]</div>
<p>Trong đó <span class="math notranslate nohighlight">\(\gamma\)</span> là hằng số và <span class="math notranslate nohighlight">\(||\mathbf{x}||_2\)</span> là <a class="reference external" href="https://phamdinhkhanh.github.io/deepai-book/ch_algebra/appendix_algebra.html#khai-niem-chuan">chuẩn bậc hai</a> của <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>.</p>
<p>Đây là một hàm có phân phối đồng dạng với phân phối chuẩn nên hình dạng của chúng là một hình quả chuông đối xứng qua điểm landmark.</p>
<p><img alt="" src="https://ds055uzetaobb.cloudfront.net/image_optimizer/1dbcc5a80e3fb541aa4678fcff58bb26ca717902.png" /></p>
<p>Giá trị của <span class="math notranslate nohighlight">\(\varphi(\mathbf{x}, l)\)</span> sẽ tiến gần tới 1 trong trường hợp <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> và <span class="math notranslate nohighlight">\(l\)</span> gần nhau và trường hợp những điểm này là cách xa nhau thì giá trị <span class="math notranslate nohighlight">\(\varphi(\mathbf{x}, l)\)</span> sẽ tiến dần tới 0.</p>
<p>Sau khi đưa thêm các đặc trưng <em>Gaussian RBF</em> vào mô hình thì các điểm phân phối gần landmark có giá trị kernel gần 1 và tách biệt so với các điểm nằm cách xa landmark có giá trị gần 0. Chúng ta sẽ thấy rõ sự tách biệt trên không gian chiếu.</p>
<p><img alt="" src="https://i.imgur.com/wlBAdui.jpeg" /></p>
<p><strong>Hình 6:</strong> Chẳng hạn trong hình minh hoạ trên chúng ta có hai điểm landmark là <span class="math notranslate nohighlight">\(l_1\)</span> và <span class="math notranslate nohighlight">\(l_2\)</span> tạo thành một hình dạng phân phối đặc trưng cho một lớp (phân phối được bao quanh bởi đường nét đứt). Điểm <span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span> gần <span class="math notranslate nohighlight">\(l_1\)</span> và <span class="math notranslate nohighlight">\(\mathbf{x}_2\)</span> nằm gần <span class="math notranslate nohighlight">\(l_2\)</span>. Khi thực hiện phép chiếu dựa trên biến đổi <em>Gaussian RBF</em>  thì toạ độ điểm <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> sẽ được ánh xạ thành:</p>
<div class="math notranslate nohighlight">
\[(\varphi(\mathbf{x}, l_1), \varphi(\mathbf{x},l_2))\]</div>
<p>Thể hiện trên hình bên phải là 3 điểm ảnh tương ứng với <span class="math notranslate nohighlight">\(\mathbf{x}_1, \mathbf{x}_2, \mathbf{x}_3\)</span> của hình bên trái. Ta nhận thấy <span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span> do gần <span class="math notranslate nohighlight">\(l_1\)</span> hơn nên có <span class="math notranslate nohighlight">\(f_1\)</span> cao và <span class="math notranslate nohighlight">\(f_2\)</span> thấp; tương tự như vậy <span class="math notranslate nohighlight">\(\mathbf{x}_2\)</span> gần <span class="math notranslate nohighlight">\(l_2\)</span> hơn nên có <span class="math notranslate nohighlight">\(f_2\)</span> cao, <span class="math notranslate nohighlight">\(f_1\)</span> thấp. <span class="math notranslate nohighlight">\(\mathbf{x}_3\)</span> thì cách xa cả hai điểm landmarks này nên có toạ độ sát điểm <span class="math notranslate nohighlight">\((0, 0)\)</span>. Trên không gian chiếu ta dễ dàng phân biệt được ảnh của các điểm này bằng một đường biên nét đứt.</p>
</div>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="kernel-trong-svm">
<h1>7.6. Kernel trong SVM<a class="headerlink" href="#kernel-trong-svm" title="Permalink to this headline">¶</a></h1>
<p>Sử dụng các phương pháp tạo lập đặc trưng thường mang lại hiệu quả. Tuy nhiên chúng có một số hạn chế đó là chúng ta phải thêm một lượng rất lớn các đặc trưng cho từng quan sát và dẫn tới chi phí tính toán gia tăng một cách đáng kể. Chẳng hạn nếu sử dụng hàm đa thức với bậc là 3 trên <span class="math notranslate nohighlight">\(n\)</span> biến thì số lượng biến bậc 3 được sinh ra có thể lên tới <span class="math notranslate nohighlight">\(C_{n}^{1}+2*C_{n}^{2} + C_{n}^{3}\)</span>, đây là một giá trị rất lớn và gây lãng phí về chi phí tính toán. Trong SVM có một kỹ thuật giúp cho vẫn có thể áp dụng các biến đổi đặc trưng trên biến đầu vào mà không cần phải tính toán các đặc trưng sau biến đổi mà ta sẽ tìm hiểu bên dưới.</p>
<p>Ở mục 7.2.5 chúng ta biết rằng nhãn của một dự báo có thể được tính trên các điểm thuộc <em>tập hỗ trợ</em>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray} h_{\mathbf{w}, b}(\mathbf{x}_i) &amp; = &amp; b + \sum_{j\in \mathcal{S}} \lambda_j y_j \mathbf{x}_{j}^{\intercal} \mathbf{x}_i \\
\end{eqnarray}\end{split}\]</div>
<p>Trong trường hợp biến đổi phi tuyến thì phương trình đường biên trở thành:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray} h_{\mathbf{w}, b}(\varphi(\mathbf{x}_i)) &amp; = &amp; b + \sum_{j\in \mathcal{S}} \lambda_j y_j \varphi(\mathbf{x}_{j})^{\intercal} \varphi(\mathbf{x}_i) \\
&amp; = &amp; b + \sum_{j\in \mathcal{S}} \lambda_j y_j \phi(\mathbf{x}_{j}, \mathbf{x}_i)
\end{eqnarray}\end{split}\]</div>
<p>Để tính toán ra hàm <span class="math notranslate nohighlight">\(\varphi()\)</span> là khá khó khăn vì có một số trường hợp <em>hàm biến đổi phi tuyến</em> <span class="math notranslate nohighlight">\(\varphi()\)</span> tồn tại dưới một dạng tiềm ẩn (<em>implicit function</em>). Tức là chúng ta không thể tìm được trực tiếp dạng hàm mà chỉ biết được chúng tồn tại. Thay vì phải tính hàm <span class="math notranslate nohighlight">\(\varphi()\)</span> thì chúng ta sẽ tìm cách tính hàm <span class="math notranslate nohighlight">\(\phi(\mathbf{x}_j, \mathbf{x}_i)\)</span> sẽ đơn giản hơn rất nhiều. Từ đó hình thành nên một kĩ thuật rất quan trọng trong SVM dựa trên những khám phá về hàm <em>hạt nhân</em> (<em>kernel function</em>) <span class="math notranslate nohighlight">\(\phi(\mathbf{x}_j, \mathbf{x}_i)\)</span> đó là kỹ thuật <em>kernel SVM</em>.</p>
<p>Tiếp theo chúng ta sẽ tìm hiểu về <em>kernel SVM</em>.</p>
<div class="section" id="khai-niem-ham-kernel-kernel-function-va-khong-gian-hilbert">
<h2>7.6.1. Khái niệm hàm kernel (<em>Kernel function</em>) và không gian Hilbert<a class="headerlink" href="#khai-niem-ham-kernel-kernel-function-va-khong-gian-hilbert" title="Permalink to this headline">¶</a></h2>
<p>Không gian tích vô hướng (<em>inner product</em>) giữa các véc tơ còn được gọi là không gian Hilbert <span class="math notranslate nohighlight">\(\langle \mathbf{x}, \mathbf{y} \rangle : \chi \times \chi \mapsto \mathcal{H}\)</span></p>
<p>Trong đó ký hiệu <span class="math notranslate nohighlight">\(\langle \mathbf{x}, \mathbf{y} \rangle\)</span> là tích vô hướng giữa hai véc tơ. <span class="math notranslate nohighlight">\(\chi \times \chi \mapsto \mathcal{H}\)</span> thể hiện rằng đây là một hàm có miền xác định là hai véc tơ trong không gian véc tơ <span class="math notranslate nohighlight">\(\chi\)</span> và được ánh xạ tới một điểm trong không gian Hilbert <span class="math notranslate nohighlight">\(\mathcal{H}\)</span>. Lưu ý không gian Hilbert không chỉ xác định trong miền số thực mà còn xác định trong miền số phức. Không gian Hilbert sẽ thoả mãn một số tính chất trên miền số thực như:</p>
<p>1-. Tính chất hoán vị:</p>
<div class="math notranslate nohighlight">
\[\langle \mathbf{x}, \mathbf{y} \rangle = \langle \mathbf{y}, \mathbf{x} \rangle\]</div>
<p>2-. Tính chất tuyến tính:</p>
<div class="math notranslate nohighlight">
\[\langle a \mathbf{x}_1 + b \mathbf{x}_2, \mathbf{y} \rangle =  a\langle \mathbf{x}_1, \mathbf{y} \rangle + b\langle \mathbf{x}_2, \mathbf{y} \rangle\]</div>
<p>Với <span class="math notranslate nohighlight">\(a, b\)</span> là những hằng số.
3-. Tích vô hướng với chính véc tơ đó là một véc tơ bán xác định dương (<em>semi - positive define</em>):</p>
<div class="math notranslate nohighlight">
\[\langle \mathbf{x}, \mathbf{x} \rangle = ||\mathbf{x}||_2^2 \succeq 0\]</div>
<p>Hàm kernel là một khái niệm có sự liên kết chặt chẽ và gần gũi với không gian Hilbert mà ở đó chúng ta không trực tiếp tính tích vô hướng giữa hai véc tơ mà thay vào đó ánh xạ hai véc tơ lên một không gian <em>bản đồ đặc trưng</em> (<em>feature map</em>) và sử dụng không gian <em>bản đồ đặc trưng</em> này như là đầu vào để ánh xạ lên không gian Hilbert.</p>
<p><strong>Lưu ý</strong>: Hàm kernel giữa hai véc tơ <span class="math notranslate nohighlight">\(\mathbf{x}, \mathbf{y}\)</span> trong cuốn sách này được ký hiệu là <span class="math notranslate nohighlight">\(\phi{}(\mathbf{x}, \mathbf{y})\)</span>. Hầu hết các tài liệu khác kí hiệu là <span class="math notranslate nohighlight">\(K(\mathbf{x}, \mathbf{y})\)</span> hoặc <span class="math notranslate nohighlight">\(k(\mathbf{x}, \mathbf{y})\)</span> nhưng bản thân tôi nhận thấy dùng chữ cái <span class="math notranslate nohighlight">\(K\)</span> hoặc <span class="math notranslate nohighlight">\(k\)</span> thì dễ bị nhầm với ma trận hoặc số vô hướng nên thay bằng hàm <span class="math notranslate nohighlight">\(\phi()\)</span>.</p>
<p>Hàm <em>đặc trưng</em> (<em>feature function</em>) có thể là một <em>hàm tiềm ẩn</em> (<em>implicit function</em>) không thể biết định dạng cụ thể hoặc là một <em>hàm hiện</em> (<em>explicit function</em>) có thể biết định dạng. Như vậy về bản chất thì kernel function chính là một hàm: <span class="math notranslate nohighlight">\(\phi(\mathbf{x}, \mathbf{y}) = \langle \varphi(\mathbf{x}), \varphi(\mathbf{y}) \rangle : \varphi(\chi) \times \varphi(\chi) \mapsto \mathcal{H}\)</span>.</p>
<p>Trong dó hàm <em>đặc trưng</em> chính là <span class="math notranslate nohighlight">\(\varphi(\mathbf{x})\)</span>.</p>
<p>Khi sử dụng hàm kernel thông thường chúng ta sẽ tìm một phép biểu diễn véc tơ <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> trong một không gian thấp chiều (<em>low-dimensional space</em>) sang một không gian cao chiều (<em>high-dimensional space</em>). Những thủ thuật biến đổi từ không gian thấp chiều sang không gian cao chiều thông qua hàm kernel được gọi là những <em>mẹo kernel</em> (<em>kernel trick</em>). Sử dụng kernel mang lại cho chúng ta hai lợi ích chính. Đó là chúng ta có thể tính được tích vô hướng giữa hai hàm <em>đặc trưng</em> mà không nhất thiết phải tìm ra biểu diễn của <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> khi được ánh xạ sang không gian cao chiều. Vì hàm <em>đặc trưng</em> có số chiều thường rất lớn nên tiết kiệm được chi phí tính toán nếu biết trước được định dạng của hàm kernel.</p>
</div>
<div class="section" id="dinh-ly-merce-ve-kernel">
<h2>7.6.2. Định lý merce về kernel<a class="headerlink" href="#dinh-ly-merce-ve-kernel" title="Permalink to this headline">¶</a></h2>
<p>Như chúng ta đã phân tích, sử dụng các hàm biến đổi phi tuyến thì thường dẫn tới sự lãng phí về chi phí tính toán. Trong khi để dự báo nhãn thì chúng ta chỉ cần sử dụng hàm kernel là đủ. Như vậy điểm mấu chốt để giảm bớt chi phí tính toán đó là chúng ta phải tìm ra được hàm kernel phù hợp.</p>
<p>Theo định lý merce thì hàm <span class="math notranslate nohighlight">\(\phi(\mathbf{x},\mathbf{y})\)</span> cần thoả mãn một số điều kiện để trở thành một hàm kernel. Trong đó một điều kiện quan trọng là <span class="math notranslate nohighlight">\(\phi()\)</span> phải là một hàm liên tục và đối xứng. Tức là <span class="math notranslate nohighlight">\(\phi(\mathbf{x},\mathbf{y}) = \phi(\mathbf{y},\mathbf{x})\)</span>. Tính chất này là để đảm bảo tồn tại một hàm <span class="math notranslate nohighlight">\(\varphi\)</span> ánh xạ các véc tơ <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> và <span class="math notranslate nohighlight">\(\mathbf{y}\)</span> lên không gian cao chiều sao cho tích vô hướng: <span class="math notranslate nohighlight">\(\phi(\mathbf{x},\mathbf{y}) = \varphi(\mathbf{x})^{\intercal} \varphi(\mathbf{y})\)</span>.</p>
<p>Lưu ý rằng hầu hết mọi hàm kernel đều thoả mãn mọi điều kiện merce nhưng vẫn có một số hàm kernel không thoả mãn vẫn hoạt động khá hiệu quả.</p>
<p>Hàm <span class="math notranslate nohighlight">\(\varphi(\mathbf{x})\)</span> ở đây là một véc tơ biểu diễn véc tơ <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> trong không gian cao chiều mới. Giả định chúng ta muốn áp dụng một hàm kernel đa thức bậc 2 dạng <span class="math notranslate nohighlight">\(\phi(\mathbf{x}, \mathbf{y}) = (\mathbf{x}^{\intercal}\mathbf{y})^2\)</span> thì <span class="math notranslate nohighlight">\(\varphi\)</span> có thể là hàm <span class="math notranslate nohighlight">\(\varphi(\mathbf{x}) = [x_1^2, \sqrt{2 x_1 x_2}, x_2^2]^{\intercal}\)</span>. Trong đó <span class="math notranslate nohighlight">\(\mathbf{x} = [x_1, x_2]\)</span> và <span class="math notranslate nohighlight">\(\mathbf{y} = [y_1, y_2]\)</span>. Thật vậy:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}
\varphi(\mathbf{x})^{\intercal} \varphi(\mathbf{y}) &amp; = &amp; [x_1^2, \sqrt{2 x_1 x_2}, x_2^2] [y_1^2, \sqrt{2 y_1 y_2}, y_2^2]^{\intercal} \\
&amp; = &amp; x_1^2y_1^2 + 2 x_1 x_2 y_1 y_2 + x_2^2 y_2^2 = (x_1 y_1 + x_2 y_2)^2 = (\mathbf{x}^{\intercal}\mathbf{y})^2
\end{eqnarray}\end{split}\]</div>
<p>Như vậy từ không gian 2 chiều, các véc tơ đã được biến đổi sang không gian 3 chiều. Trong machine learning có một số hàm kernel được sử dụng khá phổ biến. Chúng ta sẽ tìm hiểu những hàm kernel này bên dưới.</p>
</div>
<div class="section" id="cac-kernel-khac-cho-svm">
<h2>7.6.3. Các kernel khác cho SVM<a class="headerlink" href="#cac-kernel-khac-cho-svm" title="Permalink to this headline">¶</a></h2>
<p>Đây là những hàm <em>kernel</em> phổ biến đã được tích hợp bên trong package sklearn.</p>
<ul class="simple">
<li><p>Kernel RBF: Kernel RBF dựa trên hàm <em>Gaussian RBF</em>.
Hàm biến đổi phi tuyến của kernel này là <em>hàm ẩn</em> và tương đương với một đa thức với bậc vô hạn.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\phi(\mathbf{x}_1, \mathbf{x}_2) = \exp({-\gamma||\mathbf{x}_1}-\mathbf{x}_2||_2^2)\]</div>
<ul class="simple">
<li><p>Kernel tuyến tính (<em>linear</em>): Đây là tích vô hướng giữa hai véc tơ.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\phi(\mathbf{x}_1, \mathbf{x}_2) = \mathbf{x}_1^{\intercal}\mathbf{x}_2\]</div>
<ul class="simple">
<li><p>Kernel đa thức (<em>poly</em>): Tạo ra một đa thức bậc cao kết hợp giữa hai véc tơ.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\phi(\mathbf{x}_1, \mathbf{x}_2) = (\gamma \mathbf{x}_1^{\intercal}\mathbf{x}_2+r)^d\]</div>
<ul class="simple">
<li><p>Kernel Sigmoid: Dựa trên kernel về đa thức, chúng ta đưa chuyển tiếp qua hàm tanh. Hàm tanh có thể biểu diễn theo hàm sigmoid nên đây được gọi là kernel Sigmoid.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\phi(\mathbf{x}_1, \mathbf{x}_2) = \text{tanh}(\gamma \mathbf{x}_1^{\intercal}\mathbf{x}_2+r)\]</div>
<p>Trong quá trình huấn luyện SVM chúng ta cần thử với những kernel khác nhau để tìm ra một kernel hiệu quả. Ở mục 6 thực hành các bạn sẽ được làm quen với việc tuning kernel.</p>
<p>Chú ý đối với các từng kernel thì chúng ta lại có thể tuning các siêu tham số (<em>hyperameter</em>) của chúng. Chẳng hạn như trong kernel đa thức chúng ta có thể tuning đối với bậc <span class="math notranslate nohighlight">\(d\)</span> của đa thức và hệ số <span class="math notranslate nohighlight">\(\gamma\)</span>. Những phần này sẽ được hướng dẫn chi tiết hơn ở mục 6.</p>
</div>
<div class="section" id="id1">
<h2>7.6.4. Dự báo nhãn<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Nhãn của một quan sát trong mô hình <em>kernel SVM</em> sẽ phụ thuộc vào giá trị độ lớn của đường biên:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{eqnarray} h_{\mathbf{w}, b}(\varphi(\mathbf{x}_i)) &amp; = &amp; b + \mathbf{w}^{\intercal}\varphi({\mathbf{x}_i}) \\
&amp; = &amp; b + (~ \sum_{j \in \mathcal{S}}\lambda_jy_j\varphi(\mathbf{x}_j)^{\intercal} ~) \varphi(\mathbf{x}_i) \\
&amp; = &amp; b + \sum_{j\in \mathcal{S}} \lambda_j y_j \varphi(\mathbf{x}_i)^{\intercal} \varphi(\mathbf{x}_i) \\
&amp; = &amp; b + \sum_{j\in \mathcal{S}} \lambda_j y_j \phi(\mathbf{x}_i, \mathbf{x}_j)
\end{eqnarray}\end{split}\]</div>
<p>Từ dòng thứ <span class="math notranslate nohighlight">\(1\)</span> sang dòng thứ <span class="math notranslate nohighlight">\(2\)</span> là giá trị <span class="math notranslate nohighlight">\(\mathbf{w}\)</span> được tính trực tiếp từ các điểm thuộc <em>tập hỗ trợ</em>. Công thức trên rất quan trọng vì một số biến đổi kernel chúng ta sẽ không dễ dàng tìm được hàm <span class="math notranslate nohighlight">\(\varphi(\mathbf{x})\)</span> một cách trực quan. Chẳng hạn như với <em>kernel RBF</em> sẽ trả về hàm <span class="math notranslate nohighlight">\(\varphi(\mathbf{x})\)</span> tương đương với một hàm đa thức bậc vô hạn dẫn tới việc tính toán <span class="math notranslate nohighlight">\(h_{\mathbf{w}, b}(\varphi(\mathbf{x}_i))\)</span> là không khả thi và tốn kém. Nhưng thông qua hàm kernel thì chúng ta vẫn có thể tính toán được giá trị của phương trình đường biên một cách dễ dàng.</p>
</div>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="vi-du-ve-bai-toan-svm">
<h1>7.7. Ví dụ về bài toán SVM<a class="headerlink" href="#vi-du-ve-bai-toan-svm" title="Permalink to this headline">¶</a></h1>
<p>Tiếp theo chúng ta sẽ cùng sử dụng SVM để phân loại bộ dữ liệu <code class="docutils literal notranslate"><span class="pre">iris</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">RepeatedStratifiedKFold</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span>

<span class="n">iris</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">iris</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">iris</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span> <span class="c1"># 1 if virginica, 0 else</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cv</span> <span class="o">=</span> <span class="n">RepeatedStratifiedKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">svm_pl</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">((</span>
    <span class="p">(</span><span class="s2">&quot;scaler&quot;</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
    <span class="p">(</span><span class="s2">&quot;linear_svc&quot;</span><span class="p">,</span> <span class="n">SVC</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">probability</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
  <span class="p">)</span>
<span class="p">)</span>

<span class="n">svm_pl</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">svm_pl</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;accuracy&#39;</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean Accuracy: </span><span class="si">{:.03f}</span><span class="s1">, Standard Deviation Accuracy: </span><span class="si">{:.03f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">scores</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Mean Accuracy: 0.960, Standard Deviation Accuracy: 0.050
</pre></div>
</div>
</div>
</div>
<p>Dự báo cho một quan sát mới</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Dự báo nhãn</span>
<span class="n">svm_pl</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.3</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">]]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([1], dtype=int8)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Dự báo xác suất, chỉ được khi probability trong SVC() được set True.</span>
<span class="n">svm_pl</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">3.2</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.2</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">]]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[3.0000009e-14, 1.0000000e+00]])
</pre></div>
</div>
</div>
</div>
<div class="section" id="bai-toan-svm-cho-du-lieu-dang-phi-tuyen">
<h2>7.7.1. Bài toán SVM cho dữ liệu dạng phi tuyến<a class="headerlink" href="#bai-toan-svm-cho-du-lieu-dang-phi-tuyen" title="Permalink to this headline">¶</a></h2>
<p>Mặc dù SVM có kết quả khá tốt cho bài toán phân loại nhưng có một số tình huống dữ liệu là phức tạp và yêu cầu chúng ta phải thực hiện các phép biến đổi phi tuyến đối với biến đầu vào để tạo thành những đường biên phức tạp hơn. Kỹ thuật chuẩn hoá đa thức (<em>polynormial</em>) được áp dụng để tạo ra những biến bậc cao sẽ hữu ích trong những tình huống này:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_moons</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">PolynomialFeatures</span>

<span class="n">svm_ply_pl</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">((</span>
    <span class="p">(</span><span class="s2">&quot;poly_features&quot;</span><span class="p">,</span> <span class="n">PolynomialFeatures</span><span class="p">(</span><span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">)),</span>
    <span class="p">(</span><span class="s2">&quot;scaler&quot;</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
    <span class="p">(</span><span class="s2">&quot;linear_svc&quot;</span><span class="p">,</span> <span class="n">SVC</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">probability</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
  <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cv</span> <span class="o">=</span> <span class="n">RepeatedStratifiedKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">svm_ply_pl</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;accuracy&#39;</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean Accuracy: </span><span class="si">{:.03f}</span><span class="s1">, Standard Deviation Accuracy: </span><span class="si">{:.03f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scores</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">scores</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Mean Accuracy: 0.969, Standard Deviation Accuracy: 0.041
</pre></div>
</div>
</div>
</div>
<p>Như vậy sau khi áp dụng <em>chuẩn hoá đa thức</em> thì độ chính xác đã tăng lên từ <code class="docutils literal notranslate"><span class="pre">0.96</span></code> lên <code class="docutils literal notranslate"><span class="pre">0.969</span></code>. Đây là một trong những kỹ thuật thường được áp dụng để giúp cải thiện độ chính xác cho SVM.</p>
<p>Trên thực thế thì kỹ thuật chuẩn hoá đa thức cũng tương tự như việc sử dụng kernel <code class="docutils literal notranslate"><span class="pre">poly</span></code> trong module SVC. Lưu ý rằng mặc dù kỹ thuật chuẩn hoá đa thức thường mang lại sự cải tiến đáng kể về độ chính xác cho mô hình nhưng số lượng biến mà nó tạo ra bao gồm những biến tích chéo (dạng <span class="math notranslate nohighlight">\(x_1^p x_2^q\)</span>) và biến bậc cao (dạng <span class="math notranslate nohighlight">\(x_1^l\)</span>) là rất lớn. Do đó sẽ dễ xảy ra hiện tượng <em>quá khớp</em> và đồng thời gia tăng chi phí huấn luyện và tính toán.</p>
<p>Tiếp theo ta sẽ thực hành tuning kernel trong SVM.</p>
</div>
<div class="section" id="su-dung-kernel-svm">
<h2>7.7.2. Sử dụng kernel SVM<a class="headerlink" href="#su-dung-kernel-svm" title="Permalink to this headline">¶</a></h2>
<p>Khi huấn luyện mô hình SVM chúng ta cần thử với nhiều kernels khác nhau để tìm ra kernel tốt nhất cho bộ dữ liệu huấn luyện. Các kernel phổ biến đó là: <code class="docutils literal notranslate"><span class="pre">linear,</span> <span class="pre">poly,</span> <span class="pre">rbf,</span> <span class="pre">sigmoid</span></code> như đã được giới thiệu ở mục 7.5.2.</p>
<p>Ngoài ra nếu mô hình gặp hiện tượng quá khớp thì chúng ta cần điều chỉnh giảm hệ số <span class="math notranslate nohighlight">\(C\)</span> của mô hình SVM để gia tăng ảnh hưởng của thành phần kiểm soát.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_moons</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">PolynomialFeatures</span>


<span class="n">kernels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;poly&#39;</span><span class="p">,</span> <span class="s1">&#39;rbf&#39;</span><span class="p">,</span> <span class="s1">&#39;sigmoid&#39;</span><span class="p">]</span>

<span class="n">cv</span> <span class="o">=</span> <span class="n">RepeatedStratifiedKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">all_scores</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1"># Đánh giá toàn bộ các mô hình trên tập K-Fold đã chia</span>
<span class="k">for</span> <span class="n">kernel</span> <span class="ow">in</span> <span class="n">kernels</span><span class="p">:</span>
  <span class="n">svm_kn_pl</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">((</span>
      <span class="p">(</span><span class="s2">&quot;scaler&quot;</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
      <span class="p">(</span><span class="s2">&quot;linear_svc&quot;</span><span class="p">,</span> <span class="n">SVC</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span> <span class="n">probability</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
    <span class="p">)</span>
  <span class="p">)</span>
  <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">svm_kn_pl</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;accuracy&#39;</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">all_scores</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">kernel</span><span class="p">,</span> <span class="n">scores</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Draw bboxplot </span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">boxplot</span><span class="p">([</span><span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">score</span> <span class="ow">in</span> <span class="n">all_scores</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Scale&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;cm&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kernels</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">kernels</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Scores Metrics&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.0, &#39;Scores Metrics&#39;)
</pre></div>
</div>
<img alt="../_images/SVM_41_1.png" src="../_images/SVM_41_1.png" />
</div>
</div>
<p>Như vậy ta có thể thấy các kernel hiệu quả chính là <code class="docutils literal notranslate"><span class="pre">rbf</span></code> và <code class="docutils literal notranslate"><span class="pre">linear</span></code> khi cùng có giá trị trung vị vào khoảng 0.97 và cao hơn mức trung bình của kernel kém nhất là <code class="docutils literal notranslate"><span class="pre">Sigmoid</span></code> là 0.07 điểm. Đây là một mức cải thiện khá đáng kể cho một bài toán phân loại nhị phân.</p>
</div>
<div class="section" id="tuning-sieu-tham-so-cho-mot-kernel">
<h2>7.7.3. tuning siêu tham số cho một kernel<a class="headerlink" href="#tuning-sieu-tham-so-cho-mot-kernel" title="Permalink to this headline">¶</a></h2>
<p>Đối với mỗi một dạng hàm kernel, căn cứ vào phương trình của chúng ta có thể xác định được những siêu tham số cần tuning.</p>
<p>Chẳng hạn như đối với danh sách các kernel được cung cấp ở mục 5.1 thì chúng ta có thể tuning các tham số như sau:</p>
<ul class="simple">
<li><p>kernel tuyến tính: tham số C.</p></li>
<li><p>kernel đa thức: tham số <span class="math notranslate nohighlight">\(C, \gamma, d\)</span></p></li>
<li><p>kernel RBF: tham số <span class="math notranslate nohighlight">\(C, \gamma\)</span>.</p></li>
<li><p>kernel sigmoid: tham số <span class="math notranslate nohighlight">\(C, \gamma, d\)</span></p></li>
</ul>
<p>Công thức tổng quát của một mô hình SVC:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sklearn</span><span class="o">.</span><span class="n">svm</span><span class="o">.</span><span class="n">SVC</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> 
  <span class="n">C</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> 
  <span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;rbf&#39;</span><span class="p">,</span> 
  <span class="n">degree</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
  <span class="n">gamma</span><span class="o">=</span><span class="s1">&#39;scale&#39;</span><span class="p">,</span> 
  <span class="n">coef0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> 
  <span class="n">class_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
  <span class="n">decision_function_shape</span><span class="o">=</span><span class="s1">&#39;ovr&#39;</span><span class="p">,</span>
  <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Trong class SVC của sklearn thì hệ số <span class="math notranslate nohighlight">\(\gamma\)</span> tương ứng với đối số <code class="docutils literal notranslate"><span class="pre">coef0</span></code>, hệ số bậc đa thức <span class="math notranslate nohighlight">\(d\)</span> là đối số <code class="docutils literal notranslate"><span class="pre">degree</span></code>, trọng số <span class="math notranslate nohighlight">\(C\)</span> của hàm chi phí chính là đối số <code class="docutils literal notranslate"><span class="pre">C</span></code> và loại kernel là đối số <code class="docutils literal notranslate"><span class="pre">kernel</span></code>.</p>
<p>Ngoài ra trong trường hợp mẫu bị mất cân bằng nghiêm trọng thì chúng ta thiết lập <code class="docutils literal notranslate"><span class="pre">class_weight</span></code> để phạt nặng hơn những trường hợp mẫu thiểu số.</p>
<p><code class="docutils literal notranslate"><span class="pre">decision_function_shape</span></code> là đối số cho phép chúng ta cấu hình kết quả xác suất dự báo trả về là theo phương pháp <code class="docutils literal notranslate"><span class="pre">one-vs-rest</span></code> hay <code class="docutils literal notranslate"><span class="pre">one-vs-one</span></code>. Nếu theo phương pháp <code class="docutils literal notranslate"><span class="pre">one-vs-rest</span></code> thì mô hình phân loại gồm <span class="math notranslate nohighlight">\(C\)</span> nhãn sẽ được chia thành <span class="math notranslate nohighlight">\(C\)</span> bài toán phân loại con, mỗi một bài toán tương ứng với một dự báo xác suất thuộc về nhãn <span class="math notranslate nohighlight">\(i\)</span>. Còn đối với bài toán <code class="docutils literal notranslate"><span class="pre">one-vs-one</span></code> chúng ta sẽ tìm cách xây dựng <span class="math notranslate nohighlight">\(C\times(C-1)\)</span> mô hình phân loại cho một cặp nhãn <span class="math notranslate nohighlight">\((i, j)\)</span> bất kỳ. Đối với bài toán phân loại nhị phân thì <code class="docutils literal notranslate"><span class="pre">decision_function_shape</span> <span class="pre">=</span> <span class="pre">ovr</span></code> tương ứng với dự báo xác suất tương ứng với nhãn <span class="math notranslate nohighlight">\((0, 1)\)</span>.</p>
<p>Bên dưới là một ví dụ mẫu về cách tuning tham số trên GridSearch đối với mô hình SVM.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;clf__kernel&#39;</span><span class="p">:[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;rbf&#39;</span><span class="p">,</span> <span class="s1">&#39;poly&#39;</span><span class="p">,</span> <span class="s1">&#39;sigmoid&#39;</span><span class="p">],</span>  <span class="c1"># Các dạng hàm kernel</span>
    <span class="s1">&#39;clf__C&#39;</span><span class="p">:[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="c1"># Trọng số của phạt phân loại sai</span>
    <span class="s1">&#39;clf__coef0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="c1"># Tương ứng với tham số gamma của đa thức</span>
    <span class="s1">&#39;clf__degree&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="c1"># Bậc d của đa thức</span>
<span class="p">}</span>


<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span>
    <span class="n">steps</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;clf&quot;</span><span class="p">,</span> <span class="n">SVC</span><span class="p">())]</span>
<span class="p">)</span>

<span class="n">gscv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;accuracy&#39;</span><span class="p">,</span> <span class="n">return_train_score</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">error_score</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">gscv</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Fitting 5 folds for each of 72 candidates, totalling 360 fits
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>GridSearchCV(cv=5, error_score=0, estimator=Pipeline(steps=[(&#39;clf&#39;, SVC())]),
             n_jobs=12,
             param_grid={&#39;clf__C&#39;: [0.05, 1, 100], &#39;clf__coef0&#39;: [2, 4],
                         &#39;clf__degree&#39;: [1, 2, 3],
                         &#39;clf__kernel&#39;: [&#39;linear&#39;, &#39;rbf&#39;, &#39;poly&#39;, &#39;sigmoid&#39;]},
             return_train_score=True, scoring=&#39;accuracy&#39;, verbose=3)
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="tong-ket">
<h1>7.8. Tổng kết<a class="headerlink" href="#tong-ket" title="Permalink to this headline">¶</a></h1>
<p>Như vậy qua chương này bạn đọc đã được giới thiệu những kiến thức cơ bản gồm:</p>
<ol class="simple">
<li><p>Hàm mất mát trong SVM.</p></li>
<li><p>Khái niệm về đường biên và lề.</p></li>
<li><p>Bài toán phân loại SVM với đường biên mềm và đường biên cứng.</p></li>
<li><p>Các dạng bộ lọc trong SVM.</p></li>
<li><p>Phương pháp tuning tham số đối với mô hình SVM.</p></li>
</ol>
<p>SVM làm một trong những thuật toán hoạt động khá hiệu quả trong lớp các bài toán phân loại và dự báo của học có giám sát. Nắm vững thuật toán này, bạn đọc sẽ có thêm công cụ để tạo ra những mô hình mạnh giúp giải quyết những vấn đề thực tế.</p>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="bai-tap">
<h1>7.9. Bài tập<a class="headerlink" href="#bai-tap" title="Permalink to this headline">¶</a></h1>
<ol class="simple">
<li><p>Hàm mất mát của SVM có dạng là một hàm có dạng như thế nào?</p></li>
<li><p>Phương trình đường biên của SVM được xác định như thế nào?</p></li>
<li><p>Dự báo nhãn của mô hình SVM sẽ căn cứ vào đâu?</p></li>
<li><p>Giả định mô hình hồi qui SVM đang gặp hiện tượng <em>quá khớp</em>. Làm thế nào để giảm thiểu hiện tượng quá khớp cho mô hình SVM?</p></li>
<li><p>Kernel trong SVM là gì? Kernel có tác dụng như thế nào đối với mô hình SVM?</p></li>
<li><p>Nêu các tiêu chuẩn để một hàm có thể trở thành một hàm kernel?</p></li>
<li><p>Có những dạng kernel chính nào trong SVM? Đặc điểm của chúng là gì?</p></li>
<li><p>Sử dụng hàm kernel có ưu điểm gì khi dự báo nhãn?</p></li>
<li><p>Kernel RBF có <em>hàm biến đổi phi tuyến</em> là một hàm như thế nào?</p></li>
<li><p>Khi huấn luyện một mô hình SVM thì chúng ta cần tinh chỉnh những siêu tham số nào là chủ yếu?</p></li>
</ol>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="tai-lieu">
<h1>7.10. Tài liệu<a class="headerlink" href="#tai-lieu" title="Permalink to this headline">¶</a></h1>
<ol class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Support-vector_machine">SVM - wikipedia</a></p></li>
<li><p><a class="reference external" href="https://towardsdatascience.com/support-vector-machine-introduction-to-machine-learning-algorithms-934a444fca47">Support Vector Machine introduction to Machine Learning Algorithms</a></p></li>
<li><p><a class="reference external" href="https://machinelearningcoban.com/2017/04/09/smv/">SVM - Machine Learning Cơ bản</a></p></li>
<li><p><a class="reference external" href="https://www.amazon.com/Pattern-Recognition-Learning-Information-Statistics/dp/0387310738">Chapter 7, Sparse Kernel Machines - Pattern Recognition Learning Information Statistics</a></p></li>
<li><p><a class="reference external" href="https://www.amazon.com/Hands-Machine-Learning-Scikit-Learn-TensorFlow/dp/1491962291">Chapter 5, SVM - Hands-On Machine Learning with Scikit-Learn and TensorFlow</a></p></li>
<li><p><a class="reference external" href="https://scikit-learn.org/stable/modules/svm.html">SVM model sklearn</a></p></li>
<li><p><a class="reference external" href="https://towardsdatascience.com/optimization-loss-function-under-the-hood-part-iii-5dff33fa015d#:~:text=The%20loss%20function%20of%20SVM,the%20raw%20model%20output%2C%20%CE%B8%E1%B5%80x.">Optimization loss function under the hood par</a></p></li>
</ol>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./ch_ml"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="index_SVM.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">7. Giới thiệu về SVM</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="index_DecisionTree.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">8. Khái niệm về cây quyết định</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Pham Dinh Khanh<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>