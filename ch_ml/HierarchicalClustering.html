
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>14.1. Chiến lược hợp nhất (agglomerative) &#8212; Deep AI KhanhBlog</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/my.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"TeX": {"Macros": {"N": "\\mathbb{N}", "floor": ["\\lfloor#1\\rfloor", 1], "bmat": ["\\left[\\begin{array}"], "emat": ["\\end{array}\\right]"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="canonical" href="https://phamdinhkhanh.github.io/deepai-book/ch_ml/HierarchicalClustering.html" />
    <link rel="shortcut icon" href="../_static/logo.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="15. DBSCAN" href="index_DBSCAN.html" />
    <link rel="prev" title="14. Hierarchical Clustering (phân cụm phân cấp)" href="index_HierarchicalClustering.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/ML_course_logos.jpeg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Deep AI KhanhBlog</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Lời nói đầu
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Giới thiệu
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../contents.html">
   Các chương dự kiến
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ch_intro/main_contents.html">
   Mục tiêu cuốn sách
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../latex.html">
   Latex
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../grossary.html">
   Bảng thuật ngữ
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Phụ lục
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/appendix_dtypes.html">
   1. Định dạng dữ liệu
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_dtypes_basic.html">
     1.1. Các định dạng số, boolean và ký tự
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/index_pandas.html">
   2. Pandas
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_pandas.html">
     2.1. Khởi tạo dataframe
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/index_numpy.html">
   3. Numpy
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_numpy.html">
     3.1. Khởi tạo một mảng trên numpy
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/index_matplotlib.html">
   4. Matplotlib
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_matplotlib.html">
     4.1. Format chung của một biểu đồ trên matplotlib
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/index_OOP.html">
   5. Lập trình hướng đối tượng (Object Oriented Programming - OOP)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_OOP.html">
     5.1. Class và Object
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/index_pipeline.html">
   6. Sklearn Pipeline
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_pipeline.html">
     6.1. Thiết kế pipeline
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch_appendix/index_Convex_Opt.html">
   7. Giới thiệu chung về optimization
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch_appendix/appendix_Convex_Opt.html">
     7.1. Bài toán dạng tổng quát
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Đại số tuyến tính
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../ch_algebra/appendix_algebra.html">
   1. Đại số tuyến tính
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Giới thiệu
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../ch_calculus/appendix_calculus.html">
   1. Giải tích tích phân
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Xác suất
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../ch_probability/appendix_probability.html">
   1. Xác suất
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Machine Learning
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="index_MLIntroduce.html">
   1. Khái quát Machine Learning
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_prediction.html">
   2. Bài toán dự báo
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="prediction.html">
     2.1. Ứng dụng của hồi qui tuyến tính
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_RidgedRegression.html">
   2.2. Hồi qui Ridge và Lasso
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="RidgedRegression.html">
     2.2.2. Hồi qui Ridge
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_classification.html">
   3. Bài toán phân loại
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="classification.html">
     3.1. Hồi qui Logistic
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_OvfAndUdf.html">
   4. Độ chệch (
   <em>
    bias
   </em>
   ) và phương sai (
   <em>
    variance
   </em>
   )
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="OvfAndUdf.html">
     4.1. Sự đánh đổi giữa độ chệch và phương sai
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_ModelMetric.html">
   5. Thước đo mô hình phân loại
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
  <label for="toctree-checkbox-12">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="modelMetric.html">
     5.1. Bộ dữ liệu
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_creditScorecard.html">
   6. Ứng dụng mô hình scorecard
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
  <label for="toctree-checkbox-13">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="creditScorecard.html">
     6.1. Phương pháp chuyên gia và mô hình
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_SVM.html">
   7. Giới thiệu về SVM
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/>
  <label for="toctree-checkbox-14">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="SVM.html">
     7.1. Hàm mất mát của SVM
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_DecisionTree.html">
   8. Khái niệm về cây quyết định
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/>
  <label for="toctree-checkbox-15">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="DecisionTree.html">
     8.1. Mô hình cây quyết định (
     <em>
      decision tree
     </em>
     )
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_RandomForest.html">
   9. Giới thiệu về mô hình rừng cây (
   <em>
    Random Forest
   </em>
   )
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/>
  <label for="toctree-checkbox-16">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="RandomForest.html">
     9.1. Ý tưởng của mô hình rừng cây
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_Bayes.html">
   10. Bạn là
   <em>
    Tần suất
   </em>
   (
   <em>
    Frequentist
   </em>
   ) hay
   <em>
    Bayesian
   </em>
   ?
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/>
  <label for="toctree-checkbox-17">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="NaiveBayes.html">
     10.1. Ước lượng hợp lý tối đa (
     <em>
      Maximum Likelihood Function - MLE
     </em>
     )
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_FeatureEngineering.html">
   11. Giới thiệu về feature engineering
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" type="checkbox"/>
  <label for="toctree-checkbox-18">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="FeatureEngineering.html">
     11.1. Feature Engineering
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_Boosting.html">
   12. Phương pháp tăng cường (
   <em>
    Boosting
   </em>
   )
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" type="checkbox"/>
  <label for="toctree-checkbox-19">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="Boosting.html">
     12.1. AdaBoosting
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_KMeans.html">
   13. k-Means Clustering
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-20" name="toctree-checkbox-20" type="checkbox"/>
  <label for="toctree-checkbox-20">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="KMeans.html">
     13.1. Các bước của thuật toán k-Means Clustering
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="index_HierarchicalClustering.html">
   14. Hierarchical Clustering (
   <em>
    phân cụm phân cấp
   </em>
   )
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-21" name="toctree-checkbox-21" type="checkbox"/>
  <label for="toctree-checkbox-21">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     14.1. Chiến lược hợp nhất (
     <em>
      agglomerative
     </em>
     )
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_DBSCAN.html">
   15. DBSCAN
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-22" name="toctree-checkbox-22" type="checkbox"/>
  <label for="toctree-checkbox-22">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="DBSCAN.html">
     15.1. Phương pháp phân cụm dựa trên mật độ (
     <em>
      Density-Based Clustering
     </em>
     )
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_GMM.html">
   16. Gaussian Mixture Model
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-23" name="toctree-checkbox-23" type="checkbox"/>
  <label for="toctree-checkbox-23">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="GMM.html">
     16.1. Ước lượng MLE cho
     <em>
      phân phối Gaussian đa chiều
     </em>
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="index_PCA.html">
   17. Giảm chiều dữ liệu
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-24" name="toctree-checkbox-24" type="checkbox"/>
  <label for="toctree-checkbox-24">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="PCA.html">
     17.1. Phương pháp phân tích suy biến
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Đóng góp từ những tác giả khác
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../ch_donation/fubini_and_riemann.html">
   Tích phân Riemann và định lý Fubini
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../ch_donation/information_theory.html">
   Lý thuyết thông tin
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="../_sources/ch_ml/HierarchicalClustering.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/ch_ml/HierarchicalClustering.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/phamdinhkhanh/deepai-book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/phamdinhkhanh/deepai-book/issues/new?title=Issue%20on%20page%20%2Fch_ml/HierarchicalClustering.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/phamdinhkhanh/deepai-book/edit/main/book/ch_ml/HierarchicalClustering.md"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/phamdinhkhanh/deepai-book/main?urlpath=tree/book/ch_ml/HierarchicalClustering.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   14.1. Chiến lược hợp nhất (
   <em>
    agglomerative
   </em>
   )
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#khoang-cach-giua-hai-cum">
   14.2. Khoảng cách giữa hai cụm?
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#chien-luoc-phan-chia-divisive">
   14.3. Chiến lược phân chia (
   <em>
    divisive
   </em>
   )
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dieu-kien-dung-cua-thuat-toan-phan-cum">
   14.4. Điều kiện dừng của thuật toán phân cụm
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#do-phuc-tap-cua-thuat-toan-phan-cum-phan-cap">
   14.5. Độ phức tạp của thuật toán
   <em>
    phân cụm phân cấp
   </em>
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#thuc-hanh-phan-cum-phan-cap">
   14.6. Thực hành
   <em>
    phân cụm phân cấp
   </em>
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bieu-do-dendrogram">
     14.6.1. Biểu đồ dendrogram
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#xay-dung-mo-hinh-phan-cum-phan-cap-hop-nhat">
     14.6.2. Xây dựng mô hình phân cụm phân cấp hợp nhất
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tong-ket">
   14.7. Tổng kết
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#bai-tap">
   14.8. Bài tập
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tai-lieu-tham-khao">
   14.9. Tài liệu tham khảo
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="chien-luoc-hop-nhat-agglomerative">
<h1>14.1. Chiến lược hợp nhất (<em>agglomerative</em>)<a class="headerlink" href="#chien-luoc-hop-nhat-agglomerative" title="Permalink to this headline">¶</a></h1>
<p><em>Chiến lược hợp nhất</em> sẽ bắt đầu biểu diễn mỗi quan sát là một cụm đơn lẻ. Gỉa định chúng ta có <span class="math notranslate nohighlight">\(N\)</span> quan sát, thuật toán cần thực hiện <span class="math notranslate nohighlight">\(N-1\)</span> bước để hợp nhất hai nhóm có khoảng cách gần nhất lại với nhau và đồng thời giảm số lượng cụm trước khi chúng đạt được tới node gốc gồm toàn bộ các quan sát. Như vậy câu hỏi đặt ra đó là:</p>
<ul class="simple">
<li><p>Làm thế nào để xác định điểm đại diện cho một cụm?</p></li>
<li><p>Làm thế nào để xác định khoảng cách giữa hai cụm?</p></li>
<li><p>Khi nào thì thuật toán sẽ dừng?</p></li>
</ul>
<p>Hình minh hoạ bên dưới về chiến lược hợp nhất sẽ được sử dụng để làm rõ điều này:</p>
<p><img alt="" src="https://imgur.com/oBanpgP.png" /></p>
<p><strong>Hình 2</strong>: Hình minh hoạ các bước được thực hiện trên thuật toán <em>phân cụm phân cấp</em> sử dụng <em>chiến lược hợp nhất</em> đối với 6 điểm dữ liệu <span class="math notranslate nohighlight">\(\{A, B, C, D, E, F\}\)</span>. Chấm tròn thể hiện cho các điểm dữ liệu, chấm tròn có dấu x ở giữa là tâm của các cụm. Các đường elipse bao ngoài thể hiện cho các điểm được phân về cùng một cụm. Ở bên phải dưới cùng của mỗi hình là đồ thị <em>dendrogram</em> thể hiện sự gộp nhóm.</p>
<p>Bộ dữ liệu ở hình 2 bao gồm 6 điểm nên sẽ trải qua 5 bước dữ liệu để nhóm dữ liệu. Thứ tự nhóm sẽ như sau:</p>
<ul class="simple">
<li><p>Step 1: Dựa trên khoảng cách gần nhất giữa các điểm chúng ta sẽ nhóm 2 điểm <span class="math notranslate nohighlight">\(\{A, B\}\)</span> thành 1 cụm. Khi đó điểm đại diện cho một cụm <span class="math notranslate nohighlight">\(\{A, B\}\)</span> sẽ là trung bình cộng giữa hai điểm <span class="math notranslate nohighlight">\(A\)</span> và <span class="math notranslate nohighlight">\(B\)</span>, được thể hiện bằng dấu <span class="math notranslate nohighlight">\(\otimes\)</span> giữa <span class="math notranslate nohighlight">\(A\)</span> và <span class="math notranslate nohighlight">\(B\)</span> trên hình.</p></li>
<li><p>Step 2: Lựa chọn ngẫu nhiên một điểm chưa được gộp cụm, chẳng hạn điểm D. Đo khoảng cách tới các điểm còn lại và với tâm cụm <span class="math notranslate nohighlight">\(\{A, B\}\)</span> ta sẽ thu được khoảng cách <span class="math notranslate nohighlight">\(d(D, E)\)</span> là nhỏ nhất. Như vậy ta sẽ thu được một cụm <span class="math notranslate nohighlight">\(\{D, E\}\)</span>.</p></li>
<li><p>Step 3: Xuất phát từ điểm <span class="math notranslate nohighlight">\(C\)</span>, ta đo khoảng cách tới các tâm cụm <span class="math notranslate nohighlight">\(\{A, B\}\)</span> và <span class="math notranslate nohighlight">\(\{D, E\}\)</span> và tới điểm F. Khoảng cách gần nhất là <span class="math notranslate nohighlight">\(d(C, \{A, B\})\)</span> nên ta nhóm <span class="math notranslate nohighlight">\(C\)</span> vào cụm <span class="math notranslate nohighlight">\(\{A, B\}\)</span> để thu được cụm mới <span class="math notranslate nohighlight">\(\{A, B, C\}\)</span>.</p></li>
<li><p>Step 4: Xuất phát từ <span class="math notranslate nohighlight">\(F\)</span> ta đo khoảng cách tới các tâm cụm <span class="math notranslate nohighlight">\(\{A, B, C\}\)</span> và <span class="math notranslate nohighlight">\(\{D, E\}\)</span>. Điểm <span class="math notranslate nohighlight">\(F\)</span> gần cụm <span class="math notranslate nohighlight">\(\{D, E\}\)</span> hơn nên sẽ được gộp vào thành cụm <span class="math notranslate nohighlight">\(\{D, E, F\}\)</span>.</p></li>
<li><p>Step 5: Gộp cả 2 cụm <span class="math notranslate nohighlight">\(\{A, B, C\}\)</span> và <span class="math notranslate nohighlight">\(\{D, E, F\}\)</span> ta thu được cụm cuối cùng là node gốc bao trùm toàn bộ dữ liệu.</p></li>
</ul>
<p>Như vậy chúng ta đã hình dung ra chiến lược nhóm cụm rồi chứ? Chung qui lại xuất phát từ node lá, thuật toán gộp dần thành các cụm theo chiều từ dưới lên trên. Sau đó sẽ thực hiện truy hồi việc gộp cụm (cụm ở đây có thể gồm một điểm hoặc nhiều điểm). Khoảng cách giữa hai cụm được đo lường thông qua một thước đo sẽ được làm rõ hơn ở bên dưới, trong ví dụ này chính là khoảng cách trong không gian euclidean giữa tâm của mỗi cụm. Trong đó tâm cụm được xác định bằng trung bình cộng của các quan sát bên trong cụm.</p>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="khoang-cach-giua-hai-cum">
<h1>14.2. Khoảng cách giữa hai cụm?<a class="headerlink" href="#khoang-cach-giua-hai-cum" title="Permalink to this headline">¶</a></h1>
<p>Giả định tại một level cụ thể trong biểu đồ <em>dendrogram</em> chúng ta có hai cụm trung gian <strong>không trùng nhau</strong> là <span class="math notranslate nohighlight">\(\mathcal{S}_1 = \{ \mathbf{x}_i^{(1)}\}_{i=1}^{N_1}\)</span> và <span class="math notranslate nohighlight">\(\mathcal{S}_2 = \{ \mathbf{x}_j^{(2)} \}_{j=1}^{N_2}\)</span>. Khoảng cách giữa hai cụm chính là sự khác biệt giữa chúng. Có những phương pháp giúp xác định khoảng cách giữa hai cụm như sau:</p>
<ul class="simple">
<li><p><em>Ward linkage</em>: Phương pháp này đo lường khoảng cách giữa hai tâm cụm thông qua sự suy giảm phương sai. Tức là việc phân cụm sẽ được coi là hợp lý nếu như sau khi phân cụm thì phương sai giảm một giá trị lớn. Người ta còn chứng minh được rằng mức độ suy giảm của phương sai trước phân chia trên của cụm cha so với tổng phương sai sau phân chia trên hai cụm con tỷ lệ thuận với khoảng cách giữa hai tâm cụm được tính theo công thức trung bình. Trong điều kiện lý tưởng, nếu các quan sát tồn tại trong không gian euclidean thì chúng ta có thể xác định được tâm cụm dựa trên trung bình. Khi đó ta xác định khoảng cách giữa hai cụm bằng <em>khoảng cách euclidean</em> (<em>euclidean distance</em>) giữa hai tâm cụm. Cùng ôn lại kiến thức một chút, <em>khoảng cách euclidean</em> chính là độ dài đoạn thẳng nối trực tiếp hai điểm trong không gian <em>euclidean</em>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[d(\mathbf{m}_1,\mathbf{m}_2) = d(\mathbf{m}_2,\mathbf{m}_1) = \sqrt{(m_{1}^{(1)} -m_1^{(2)})^2 + (m_2^{(1)} - m_2^{(2)})^2 + \cdots + (m_n^{(1)} -m_n^{(2)})^2} = \sqrt{\sum_{i=1}^{n} (m_i^{(1)}-m_i^{(2)})^2}
\]</div>
<p>Thuật toán <em>ward linkage</em> cũng chỉ được sử dụng trong điều kiện giả định các quan sát nằm trong không gian euclidean.</p>
<p>Tiếp theo ta sẽ chứng minh công thức mức độ suy giảm phương sai theo khoảng cách giữa hai tâm cụm. Giả sử <span class="math notranslate nohighlight">\(\mathbf{m}, \mathbf{m}_1, \mathbf{m}_2\)</span> lần lượt là trung bình của tâm cụm cha <span class="math notranslate nohighlight">\(\{\mathcal{S}_1, \mathcal{S}_2\}\)</span>, và hai cụm con <span class="math notranslate nohighlight">\(\mathcal{S}_1\)</span> và <span class="math notranslate nohighlight">\(\mathcal{S}_2\)</span>. Khi đó thước đo khoảng cách <em>ward linkage</em> có công thức như sau:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}d(\mathcal{S}_1, \mathcal{S}_2) &amp; = &amp; \sum_{\mathbf{x}_i \in \mathcal{S_1} \cup \mathcal{S}_2} \| \mathbf{x}_i-\mathbf{m} \|^2 - \sum_{\mathbf{x}_i \in \mathcal{S}_1} \| \mathbf{x}_i - \mathbf{m}_1\|^2 - \sum_{\mathbf{x}_i \in \mathcal{S}_2} \| \mathbf{x}_i - \mathbf{m}_2\|^2 \\
&amp; = &amp; \frac{N_1 N_2}{N_1 + N_2} \| \mathbf{m}_1 - \mathbf{m}_2 \|^2 \\
&amp; = &amp; \frac{N_1 N_2}{N_1 + N_2} d(\mathbf{m}_1, \mathbf{m}_2) \tag{1}
\end{eqnarray}\end{split}\]</div>
<p>Ta có thể chứng minh công thức <span class="math notranslate nohighlight">\((1)\)</span> như sau:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{eqnarray}d(\mathcal{S}_1, \mathcal{S}_2) &amp; = &amp;
\sum_{\mathbf{x}_i \in \mathcal{S_1} \cup \mathcal{S}_2} \| \mathbf{x}_i-\mathbf{m} \|^2 - \sum_{\mathbf{x}_i \in \mathcal{S}_1} \| \mathbf{x}_i - \mathbf{m}_1\|^2 - \sum_{\mathbf{x}_i \in \mathcal{S}_2} \| \mathbf{x}_i - \mathbf{m}_2\|^2 \\
&amp; = &amp; \sum_{\mathbf{x}_i \in \mathcal{S}_1}[ \| \mathbf{x}_i - \mathbf{m}\|^2 - \| \mathbf{x}_i - \mathbf{m}_1\|^2] + \sum_{\mathbf{x}_i \in \mathcal{S}_2}[ \| \mathbf{x}_i - \mathbf{m}\|^2 - \| \mathbf{x}_i - \mathbf{m}_2\|^2] \\
&amp; = &amp; \sum_{\mathbf{x}_i \in \mathcal{S}_1} (2 \mathbf{x}_i - \mathbf{m} - \mathbf{m}_1)(\mathbf{m}_1-\mathbf{m}) + \sum_{\mathbf{x}_i \in \mathcal{S}_2} (2 \mathbf{x}_i - \mathbf{m} - \mathbf{m}_2)(\mathbf{m}_2-\mathbf{m}) \\
&amp; = &amp; (2 \underbrace{\sum_{\mathbf{x}_i \in \mathcal{S}_1}\mathbf{x}_i}_{N_1 \mathbf{m}_1} - N_1 \mathbf{m} - N_1 \mathbf{m}_1)(\mathbf{m}_1-\mathbf{m}) + (2 \underbrace{\sum_{\mathbf{x}_i \in \mathcal{S}_2} \mathbf{x}_i}_{N_2\mathbf{m}_2} - N_2\mathbf{m} - N_2\mathbf{m}_2)(\mathbf{m}_2-\mathbf{m})\\
&amp; = &amp; N_1 (\mathbf{m}_1 - \mathbf{m})^2+N_2(\mathbf{m}_2-\mathbf{m})^2 \\
&amp; = &amp; N_1 (\mathbf{m}_1 - \frac{N_1\mathbf{m}_1 + N_2\mathbf{m}_2}{N_1 + N_2})^2+N_2(\mathbf{m}_2-\frac{N_1\mathbf{m}_1 + N_2\mathbf{m}_2}{N_1 + N_2})^2 \\
&amp; = &amp; \frac{N_1N_2}{N_1 + N_2} \|\mathbf{m}_1 - \mathbf{m}_2\|^2
 \end{eqnarray}\end{split}\]</div>
<p>Công thức <span class="math notranslate nohighlight">\((1)\)</span> cho thấy việc phân cụm luôn khiến phương sai dữ liệu giảm. Tuy nhiên mức độ suy giảm nhiều hay ít sẽ phụ thuộc và khoảng cách <em>tâm</em> (<em>centroids</em>) giữa hai cụm. Nếu hai tâm cách xa nhau thì giá trị giảm của phương sai sau khi phân cụm càng lớn. Trái lại nếu tâm giữa hai cụm càng sát nhau, các cụm có xu hướng chồng lấn và không rõ ràng thì sau khi phân chia phương sai của cụm giảm không đáng kể. Trường hợp này tiếp tục phân chia cũng không có nhiều ý nghĩa, thậm chí có thể phá vỡ qui luật phân phối tổng quát của một cụm. Mức độ suy giảm phương sai cũng tỷ lệ thuận với khoảng cách giữa hai tâm được tính theo trung bình. Trường hợp này tâm còn gọi là <em>centroids</em> để phân biệt với <em>clusteroids</em> được giới thiệu bên dưới.</p>
<p>Trong nhiều trường hợp khi dữ liệu không tồn tại trong không gian euclidean (non-euclidean) thì chúng ta không thể tính toán được tâm của từng cụm theo trung bình toàn bộ các điểm trong cụm. Khi đó tâm cụm sẽ được xác định là một điểm nằm trong cụm sao cho có trung bình khoảng cách tới những điểm khác trong cùng cụm là nhỏ nhất. Như vậy ta đã thay thế trung bình bằng một điểm dữ liệu thực tế, những điểm này còn được gọi là <em>clustroids</em>.</p>
<p>Ngoài phương pháp <em>Ward linkage</em>, để đo lường sự không tương đồng giữa các cụm còn có những phương pháp sau đây:</p>
<ul class="simple">
<li><p><em>Single linkage</em>: Phương pháp này đo lường sự khác biệt giữa hai cụm bằng cách lấy ra cặp điểm gần nhất giữa hai cụm. Độ đo sự khác biệt được tính theo công thức:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[d(\mathcal{S}_1, \mathcal{S}_2) = \min_{\mathbf{x}_i \in \mathcal{S}_1, \mathbf{x}_j \in \mathcal{S}_2}d(\mathbf{x}_i^{(1)}, \mathbf{x}_j^{(2)})\]</div>
<p>Phương pháp này còn được gọi dưới một tên khác là <em>nearest-neighbor</em>. Tức là đo lường khoảng cách cụm thông qua 2 điểm gần nhau nhất thuộc mỗi cụm.</p>
<ul class="simple">
<li><p><em>Complete linkage</em>: Phương pháp này đo lường sự khác biệt giữa hai cụm bằng cách lấy ra hai cặp điểm xa nhau nhất giữa hai cụm.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[d(\mathcal{S}_1, \mathcal{S}_2) = \max_{\mathbf{x}_i \in \mathcal{S}_1, \mathbf{x}_j \in \mathcal{S}_2}d(\mathbf{x}_i^{(1)}, \mathbf{x}_j^{(2)})\]</div>
<ul class="simple">
<li><p><em>Group average</em>: Phương pháp này sẽ lấy trung bình toàn bộ khoảng cách giữa các cặp điểm được lấy từ hai cụm. Chúng ta sẽ có tổng cộng <span class="math notranslate nohighlight">\(N_1 N_2\)</span> cặp điểm. Như vậy khoảng cách sẽ được tính bằng:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[d(\mathcal{S}_1, \mathcal{S}_2) = \frac{1}{N_1 N_2}\sum_{i=1}^{N_1} \sum_{j=1}^{N_2}d(\mathbf{x}_i^{(1)}, \mathbf{x}_j^{(2)})\]</div>
<p>Cả bốn phương pháp <em>ward linkage, sinlge linkage, complete linkage, group average</em> đều giúp tạo ra một thước đo về sự không tương đồng hay chính là khoảng cách giữa hai cụm. Khi giữa các cụm có sự tách biệt thể hiện qua phân phối dữ liệu và đường biên phân chia rõ rệt thì kết quả trả về <span class="math notranslate nohighlight">\(d(\mathcal{S}_1, \mathcal{S}_2)\)</span> đều thu được lớn và trái lại. Tuy nhiên phương pháp <em>single linkage</em> và <em>complete linkage</em> thường bị ảnh hưởng bởi những điểm dữ liệu outliers. Chẳng hạn hai cụm rất cách xa nhau nhưng do hai điểm outliers của chúng lại rất gần nhau có thể trả về một khoảng cách theo <em>single linkage</em> rất bé. Một tình huống khác, khi hai cụm rất gần nhau nhưng do hai điểm outliers của chúng rất xa nên khoảng cách được đo theo <em>complete linkage</em> lại rất lớn. trong khi đó <em>ward linkage</em> và <em>group average</em> ít bị ảnh hưởng bởi outliers hơn. Tuy nhiên <em>ward linkage</em> lại chỉ có thể hoạt động khi các điểm dữ liệu tồn tại trong không gian euclidean.</p>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="chien-luoc-phan-chia-divisive">
<h1>14.3. Chiến lược phân chia (<em>divisive</em>)<a class="headerlink" href="#chien-luoc-phan-chia-divisive" title="Permalink to this headline">¶</a></h1>
<p><em>Chiến lược phân chia</em> chưa được nghiên cứu và phát triển rộng rãi trong các bài toán phân cụm như hợp nhất. Trong sklearn cũng chưa có module phát triển cho phương pháp này. Nó được giới thiệu lần đầu trong một tài liệu của Gersho và Grey, 1992 về kĩ thuật nén. <em>Chiến lược phân chia</em> sẽ bắt đầu từ một cụm gồm toàn bộ các quan sát bên trong cụm và sau đó phân chia đệ qui những cụm đang tồn tại thành hai cụm con tại mỗi bước theo hướng top-down.</p>
<p>Đầu tiên thuật toán sẽ chọn ra một điểm từ toàn bộ tập dữ liệu <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> sao cho điểm này thoả mãn điều kiện trung bình khoảng cách từ điểm đó tới toàn bộ những điểm còn lại là nhỏ nhất. Chúng ta đưa điểm này vào tập <span class="math notranslate nohighlight">\(\mathcal{S}_1\)</span>, tập còn lại gồm <span class="math notranslate nohighlight">\(N-1\)</span> điểm là tập <span class="math notranslate nohighlight">\(\mathcal{S}_2\)</span>. Tiếp theo ta sẽ thực hiện các lượt phân chia sao cho mỗi một lượt lựa chọn ra một điểm <span class="math notranslate nohighlight">\(\mathbf{x}_i\)</span> từ tập <span class="math notranslate nohighlight">\(\mathcal{S}_2\)</span> đưa sang <span class="math notranslate nohighlight">\(\mathcal{S}_1\)</span>. Điểm này cần thoả mãn hai điều kiện:</p>
<ul class="simple">
<li><p>Trung bình khoảng cách từ điểm đó tới toàn bộ các điểm còn lại trong <span class="math notranslate nohighlight">\(\mathcal{S}_1\)</span> phải là nhỏ nhất. Điều đó có nghĩa là <span class="math notranslate nohighlight">\(\mathbf{x}_i\)</span> là điểm tách biệt nhất so với phần còn lại của <span class="math notranslate nohighlight">\(\mathcal{S}_1\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\mathbf{x}_i = \arg \max_{\mathbf{x}_i} \frac{1}{|\mathcal{S}_1|-1} \sum_{j=1, j \neq i}^{|\mathcal{S}_1|} d(\mathbf{x}_i, \mathbf{x}_j)\]</div>
<ul class="simple">
<li><p>Khoảng cách tối thiểu từ <span class="math notranslate nohighlight">\(\mathbf{x}_i\)</span> tới các điểm trong <span class="math notranslate nohighlight">\(\mathcal{S}_2\)</span> phải lớn hơn khoảng cách tối thiểu tới các điểm trong <span class="math notranslate nohighlight">\(\mathcal{S}_1\)</span>. Điều này nhằm mục đích khiến cho điểm <span class="math notranslate nohighlight">\(\mathbf{x}_i\)</span> phải gần với cụm <span class="math notranslate nohighlight">\(\mathcal{S}_2\)</span> hơn cụm <span class="math notranslate nohighlight">\(\mathcal{S}_1\)</span>.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[d(\mathbf{x}_i, \mathcal{S}_1) \geq d(\mathbf{x}_i, \mathcal{S}_2)\]</div>
<p>Trong đó:</p>
<div class="math notranslate nohighlight">
\[d(\mathbf{x}_i, \mathcal{S}_k) = \min_{\mathbf{x}_j, \mathbf{x}_j \in \mathcal{S}_k} d(\mathbf{x}_i, \mathbf{x}_j)\]</div>
<p>Qúa trình chuyển cụm sẽ kết thúc khi không còn điểm nào thoả mãn hai điều kiện trên. Khi đó chúng ta lại thực hiện đệ qui lại quá trình trên trên từng tập <span class="math notranslate nohighlight">\(\mathcal{S}_1\)</span> và <span class="math notranslate nohighlight">\(\mathcal{S}_2\)</span>.</p>
<p>Chúng ta cùng diễn giải lại quá trình này thông qua hình minh hoạ bên dưới:</p>
<p><img alt="" src="https://imgur.com/SWdmUac.png" /></p>
<p><strong>Hình 3:</strong> Hình minh hoạ <em>phương pháp phân chia</em> trong thuật toán <em>phân cụm phân cấp</em>. Ở bước 1 chúng ta sẽ lựa chọn ra điểm <span class="math notranslate nohighlight">\(C\)</span> là điểm đầu tiên thuộc cụm mới dựa trên khoảng cách so với các điểm còn lại là xa nhất. Sau bước 1 ta thu được tập <span class="math notranslate nohighlight">\(\mathcal{S}_1 = \{ C \}\)</span> và <span class="math notranslate nohighlight">\(\mathcal{S}_2 = \{A, B, D, E, F\}\)</span>. Tại bước 2 lựa chọn trong số các điểm thuộc <span class="math notranslate nohighlight">\(\mathcal{S}_2\)</span> ra điểm mà có khoảng cách xa nhất so với những điểm còn lại sao cho điểm này gần với <span class="math notranslate nohighlight">\(C\)</span> hơn so với các điểm thuộc tập <span class="math notranslate nohighlight">\(\mathcal{S}_2\)</span>, đó chính là diểm <span class="math notranslate nohighlight">\(A\)</span>. Di chuyển điểm này sang <span class="math notranslate nohighlight">\(\mathcal{S}_1\)</span>. Bước 3 chúng ta lại tiếp tục thực hiện như vậy và lựa chọn được điểm <span class="math notranslate nohighlight">\(B\)</span> để đưa sang <span class="math notranslate nohighlight">\(\mathcal{S}_1\)</span>. Ở bước thứ 4 ta sẽ dừng quá trình chuyển cụm cho các điểm thuộc <span class="math notranslate nohighlight">\(\mathcal{S}_2\)</span> vì thuật toán đã đạt sự hội tụ về hai cụm. Khi đó ta lại tiếp tục tiến hành đệ qui thuật toán trên từng cụm con.</p>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="dieu-kien-dung-cua-thuat-toan-phan-cum">
<h1>14.4. Điều kiện dừng của thuật toán phân cụm<a class="headerlink" href="#dieu-kien-dung-cua-thuat-toan-phan-cum" title="Permalink to this headline">¶</a></h1>
<p>Qúa trình phân cụm theo cả hai chiến lược <em>phân chia</em> và <em>hợp nhất</em> đều thu được một đồ thị <em>dendrogram</em> dạng cây nhị phân. Mỗi một node trong cây nhị phân sẽ xác định một cụm dữ liệu. Nhưng làm thế nào để xác định khi nào sẽ ngừng tiếp tục phân chia hoặc hợp nhất đối với một node để tạo thành kết quả phân cụm khái quát. Bên dưới là những phương pháp chính giúp xác định quá trình dừng phân cụm:</p>
<ul class="simple">
<li><p>Chúng ta sẽ xác định trước số lượng <span class="math notranslate nohighlight">\(k\)</span> cụm cần phân chia ở tầng cao nhất. Ở đây tầng càng cao nếu như cụm càng xuất phát gần gốc nhất. Sau đó chúng ta sẽ dừng thuật toán phân chia nếu như số lượng các cụm đạt được là chạm ngưỡng bằng <span class="math notranslate nohighlight">\(k\)</span>. Phương pháp lựa chọn <span class="math notranslate nohighlight">\(k\)</span> sẽ phù hợp nếu như ta biết trước dữ liệu có bao nhiêu cụm. Các bạn sẽ nắm rõ hơn điều này ở phần thực hành.</p></li>
<li><p>Thuật toán sẽ dừng nếu như việc gộp cụm tạo thành những cụm có <em>độ gắn kết</em> (<em>cohension</em>) thấp hơn. <em>Độ gắn kết</em> là một tiêu chuẩn để đo chất lượng cụm được tạo thành. Thông thường chúng ta có thể đo lường <em>độ gắn kết</em> dựa trên <em>đường kính</em> (<em>diameter</em>) của cụm sau gộp, đường kính được tính bằng khoảng cách lớn nhất giữa hai điểm trong cụm. Một cách khác đó là tính theo <em>bán kính</em> (<em>radius</em>) được xét bằng khoảng cách lớn nhất từ một điểm tới <em>centroids</em> hoặc <em>clustroids</em> của cụm. Tuy nhiên cách tiếp cận dựa trên <em>đường kính</em> hoặc <em>bán kính</em> thường bị nhạy cảm với outliers. Tức là một cụm có thể có chất lượng tốt khi phân bố của các điểm dữ liệu cô đặc xung quanh tâm nhưng do các điểm outliers làm sai lệch đường kính hoặc bán kính của cụm khiến cho cụm bị coi là không tốt. Một phương pháp khác dựa trên <em>cách tiếp cận mật độ</em> (<em>density-based</em>) bằng cách tính tỷ số giữa số lượng điểm nằm trong cụm chia cho luỹ thừa bậc hai hoặc bậc 3 của đường kính hoặc bán kính của cụm. Phương pháp này thường giúp xác định được cụm phân chia tổng quát hơn.</p></li>
</ul>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="do-phuc-tap-cua-thuat-toan-phan-cum-phan-cap">
<h1>14.5. Độ phức tạp của thuật toán <em>phân cụm phân cấp</em><a class="headerlink" href="#do-phuc-tap-cua-thuat-toan-phan-cum-phan-cap" title="Permalink to this headline">¶</a></h1>
<p>Trong thuật toán <em>phân cụm phân cấp</em> tại mỗi bước chúng ta cần phải tính khoảng cách cho từng cặp điểm trong cùng một cụm và cặp điểm thuộc hai cụm là hai tập <em>vách ngăn</em> (<em>partition set</em>). Như vậy độ phức tạp tính toán sẽ là <span class="math notranslate nohighlight">\(O(N^2)\)</span> trên mỗi bước, trong đó <span class="math notranslate nohighlight">\(N\)</span> là số lượng quan sát. Chúng ta lặp lại <span class="math notranslate nohighlight">\(N\)</span> bước cho từng điểm dữ liệu nên độ phức tạp tính toán của thuật toán sẽ là <span class="math notranslate nohighlight">\(O(N^3)\)</span>. Đây là một chi phí tính toán không hề nhỏ đối với những bộ dữ liệu lớn. Do đó chúng ta chỉ nên áp dụng thuật toán <em>phân cụm phân cấp</em> đối với những bộ dữ liệu nhỏ kích thước dưới vài chục nghìn quan sát.</p>
<p>Ngoài ra khi triển khai thuật toán, nếu khéo léo sử dụng ưu tiên queue thì có thể giảm độ phức tạp xuống <span class="math notranslate nohighlight">\(O(N^2\log N)\)</span>. Tuy nhiên hiệu quả về chi phí tính toán (<em>computational complexity</em>) thường đánh đổi bằng sự gia tăng chi phí lưu trữ (<em>space complexity</em>). Trường hợp này chi phí lưu trữ vẫn rất tốn kém đối với những bộ dữ liệu vượt quá kích thước lưu trữ của bộ nhớ.</p>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="thuc-hanh-phan-cum-phan-cap">
<h1>14.6. Thực hành <em>phân cụm phân cấp</em><a class="headerlink" href="#thuc-hanh-phan-cum-phan-cap" title="Permalink to this headline">¶</a></h1>
<p>Đầu tiên chúng ta cần import các packages cần thiết được sử dụng trong bài toán phân loại. Trong sklearn, thuật toán <em>phân cụm phân cấp</em> được phát triển dựa trên <em>chiến lược hợp nhất</em> thông qua class <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering">sklearn.cluster.AgglomerativeClustering</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">AgglomerativeClustering</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>
<span class="kn">import</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="k">as</span> <span class="nn">shc</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.patheffects</span> <span class="k">as</span> <span class="nn">PathEffects</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<p>Để minh hoạ thuật toán phân cụm, chúng ta sử dụng dữ liệu <a class="reference external" href="https://raw.githubusercontent.com/phamdinhkhanh/datasets/cf391fa1a7babe490fdd10c088f0ca1b6d377f59/shopping-data.csv">shopping data</a>. Bộ dữ liệu này mô tả hành vi mua sắm của những khách hàng theo giới tính, độ tuổi, thu nhập hàng năm và điểm số mua sắm của họ.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;https://raw.githubusercontent.com/phamdinhkhanh/datasets/cf391fa1a7babe490fdd10c088f0ca1b6d377f59/shopping-data.csv&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(200, 4)
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Genre</th>
      <th>Age</th>
      <th>Annual Income (k$)</th>
      <th>Spending Score (1-100)</th>
    </tr>
    <tr>
      <th>CustomerID</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>Male</td>
      <td>19</td>
      <td>15</td>
      <td>39</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Male</td>
      <td>21</td>
      <td>15</td>
      <td>81</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Female</td>
      <td>20</td>
      <td>16</td>
      <td>6</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Female</td>
      <td>23</td>
      <td>16</td>
      <td>77</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Female</td>
      <td>31</td>
      <td>17</td>
      <td>40</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Để đơn giản hoá, chúng ta chỉ sử dụng hai thông tin chính là thu nhập và điểm mua sắm để xây dựng mô hình. Trước tiên cần biểu đồ hoá dữ liệu shopping để nhận biết khái quát qui luật của các cụm.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Lấy ra thu nhập va điểm shopping</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(200, 2)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Biểu đồ hoá các điểm dữ liệu trên đồ thị scatter plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Annual Income k$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Spending Score&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Distribution of Shopping Dataset&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.0, &#39;Distribution of Shopping Dataset&#39;)
</pre></div>
</div>
<img alt="../_images/HierarchicalClustering_14_1.png" src="../_images/HierarchicalClustering_14_1.png" />
</div>
</div>
<p>Ta nhận thấy sự phân bố của dữ liệu có thể được chia thành 5 cụm khác nhau. Trong đó có 1 cụm ở trung tâm và 4 cụm còn lại nằm ở 4 góc.</p>
<p>Trước khi tiến hành xây dựng mô hình phân cụm, chúng ta cần chuẩn hoá giữ liệu để loại bỏ sự khác biệt về mặt đơn vị giữa các chiều. Phương pháp chuẩn hoá được áp dụng là MinMaxScaler.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">std</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
<span class="n">X_std</span> <span class="o">=</span> <span class="n">std</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bieu-do-dendrogram">
<h2>14.6.1. Biểu đồ dendrogram<a class="headerlink" href="#bieu-do-dendrogram" title="Permalink to this headline">¶</a></h2>
<p>Trong phương pháp <em>phân cụm phân cấp</em>, biểu đồ <em>dendrogram</em> có thể giúp xác định được số lượng cụm được phân chia hợp lý. Bằng cách vẽ một đường thẳng nằm ngang tương ứng với một mức độ khác biệt của các cụm, ta có thể xác định được có bao nhiêu cụm được phân chia có level nằm bên dưới đoạn thẳng này. Số lượng các điểm dữ liệu trong từng cụm cũng được thể hiện trong biểu đồ. Mức độ khác biệt giữa các cụm sẽ được thể hiện qua độ cao của các node. Một biểu đồ mà có các cụm bên dưới nằm thấp hơn so với các cụm bên trên thì thường là những bộ dữ liệu mà phương pháp <em>phân cụm phân cấp</em> đã xác định được qui luật phân cụm tổng quát.</p>
<p>Tiếp theo ta sẽ vẽ biểu đồ <em>dendrogram</em> để nhận biết các cụm cần phân chia. Để vẽ biểu đồ này chúng ta sử dụng package <code class="docutils literal notranslate"><span class="pre">scipy.cluster.hierarchy.dendrogram</span></code>. Phương pháp được sử dụng để xác định các cụm là <em>Ward linkage</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Customer Dendograms&quot;</span><span class="p">)</span>
<span class="n">dend</span> <span class="o">=</span> <span class="n">shc</span><span class="o">.</span><span class="n">dendrogram</span><span class="p">(</span><span class="n">shc</span><span class="o">.</span><span class="n">linkage</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ward&#39;</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;sample indice&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;dissimilarity metric cluster&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;dissimilarity metric cluster&#39;)
</pre></div>
</div>
<img alt="../_images/HierarchicalClustering_19_1.png" src="../_images/HierarchicalClustering_19_1.png" />
</div>
</div>
<p>Trong biểu đồ <em>dendogram</em> mà bạn nhìn thấy ở trên, trục hoành (<em>horizontal axis</em>) là thứ tự index của các quan sát trong bộ dữ liệu gốc, trục tung (<em>vertical axis</em>) thể hiện mức độ khác biệt giữa các cụm được tính toán thông qua thước đo sự khác biệt, trong biểu đồ trên chính là khoảng cách cụm được tính theo phương pháp <em>Ward linkage</em>. Nhìn vào đồ thị <em>dendrogram</em> ta có thể dễ dàng xác định được rằng với cùng một giá trị mức độ khác biệt là 200 thì chúng ta có thể tạo thành 5 cụm phân biệt.</p>
</div>
<div class="section" id="xay-dung-mo-hinh-phan-cum-phan-cap-hop-nhat">
<h2>14.6.2. Xây dựng mô hình phân cụm phân cấp hợp nhất<a class="headerlink" href="#xay-dung-mo-hinh-phan-cum-phan-cap-hop-nhat" title="Permalink to this headline">¶</a></h2>
<p>Để xây dựng biểu đồ <em>phân cụm phân cấp</em> theo <em>phương pháp hợp nhất</em> chúng ta sử dụng class <a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering">sklearn.cluster.AgglomerativeClustering</a>. Trong class này chúng ta cần khai báo các thông tin:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AgglomerativeClustering</span><span class="p">(</span>
  <span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  
  <span class="n">affinity</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
  <span class="n">compute_full_tree</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> 
  <span class="n">linkage</span><span class="o">=</span><span class="s1">&#39;ward&#39;</span><span class="p">,</span> 
  <span class="n">distance_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
  <span class="n">compute_distances</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Trong đó <code class="docutils literal notranslate"><span class="pre">n_clusters</span></code> là số lượng cụm cần phân chia. <code class="docutils literal notranslate"><span class="pre">affinity</span></code> là phương pháp tính khoảng cách giữa các quan sát. Đây có thể là bất kì độ đo khoảng cách nào, trong đó 5 khoảng cách thông dụng nhất là <code class="docutils literal notranslate"><span class="pre">euclidean,</span> <span class="pre">l1,</span> <span class="pre">l2,</span> <span class="pre">manhattan,</span> <span class="pre">cosine</span></code>. <code class="docutils literal notranslate"><span class="pre">linkage</span></code> là phương pháp áp dụng để tính khoảng cách giữa các cụm bao gồm <code class="docutils literal notranslate"><span class="pre">ward,</span> <span class="pre">complete,</span> <span class="pre">average,</span> <span class="pre">single</span></code> trong đó mặc định là <code class="docutils literal notranslate"><span class="pre">ward</span></code>.</p>
<p>Bên dưới chúng ta sẽ cùng khởi tạo một thuật toán phân cụm với 5 cụm, sử dụng khoảng các cụm là <code class="docutils literal notranslate"><span class="pre">ward</span> <span class="pre">linkage</span></code> và phương pháp tính khoảng cách giữa các điểm là <code class="docutils literal notranslate"><span class="pre">euclidean</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">AgglomerativeClustering</span>

<span class="n">cluster</span> <span class="o">=</span> <span class="n">AgglomerativeClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">affinity</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="n">linkage</span><span class="o">=</span><span class="s1">&#39;ward&#39;</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_std</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Vẽ biểu đồ các cụm trong không gian hai chiều</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_plot_kmean_scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    X: dữ liệu đầu vào</span>
<span class="sd">    labels: nhãn dự báo</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># lựa chọn màu sắc</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
    <span class="n">palette</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sns</span><span class="o">.</span><span class="n">color_palette</span><span class="p">(</span><span class="s2">&quot;hls&quot;</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">))</span>

    <span class="c1"># vẽ biểu đồ scatter</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">()</span>
    <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">palette</span><span class="p">[</span><span class="n">labels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)])</span>

    <span class="c1"># thêm nhãn cho mỗi cluster</span>
    <span class="n">txts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_classes</span><span class="p">):</span>
        <span class="c1"># Vẽ text tên cụm tại trung vị của mỗi cụm</span>
        <span class="n">xtext</span><span class="p">,</span> <span class="n">ytext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">txt</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">xtext</span><span class="p">,</span> <span class="n">ytext</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>
        <span class="n">txt</span><span class="o">.</span><span class="n">set_path_effects</span><span class="p">([</span>
            <span class="n">PathEffects</span><span class="o">.</span><span class="n">Stroke</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">foreground</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">),</span>
            <span class="n">PathEffects</span><span class="o">.</span><span class="n">Normal</span><span class="p">()])</span>
        <span class="n">txts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">txt</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;t-sne visualization&#39;</span><span class="p">)</span>

<span class="n">_plot_kmean_scatter</span><span class="p">(</span><span class="n">X_std</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/HierarchicalClustering_24_0.png" src="../_images/HierarchicalClustering_24_0.png" />
</div>
</div>
</div>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="tong-ket">
<h1>14.7. Tổng kết<a class="headerlink" href="#tong-ket" title="Permalink to this headline">¶</a></h1>
<p>Như vậy qua bài naỳ bạn đã nắm được ý tưởng đằng sau thuật toán <em>phân cụm phân cấp</em>. Đây là thuật toán dựa trên chiến lược phân chia (<em>divisive</em>) hoặc hợp nhất (<em>agglomerative</em>) các cụm theo sơ đồ  của đồ thị <em>dendrogram</em>. Thuật toán sẽ bao gồm <span class="math notranslate nohighlight">\(N\)</span> bước, tại mỗi bước ta sẽ tìm cách gộp hoặc tách một điểm vào một cụm dựa trên khoảng cách của nó với những điểm còn lại. Thuật toán sẽ dừng cho đến khi đạt ngưỡng về số lượng cụm hoặc đạt ngưỡng về chất lượng của một cụm như đường kính, bán kính, mật độ điểm.</p>
<p>Mặc dù là thuật toán khá hiệu quả nhưng <em>phân cụm phân cấp</em> lại có chi phí tính toán khá lớn, lên tới <span class="math notranslate nohighlight">\(O(N^3)\)</span>. Do đó chỉ nên áp dụng phương pháp này đối với những bộ dữ liệu có kích thước vừa phải. Để củng cố lại kiến thức về thuật toán <em>phân cụm phân cấp</em> chúng ta hãy cùng làm những bài tập bên dưới.</p>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="bai-tap">
<h1>14.8. Bài tập<a class="headerlink" href="#bai-tap" title="Permalink to this headline">¶</a></h1>
<ol class="simple">
<li><p>Có những chiến lược phân cụm nào trong thuật toán <em>phân cụm phân cấp</em>?</p></li>
<li><p>Theo chiến lược hợp nhất, ở thời điểm ban đầu chúng ta có tổng cộng bao nhiêu cụm?</p></li>
<li><p>Phương pháp <em>phân cụm phân cấp</em> sẽ trải qua bao nhiêu bước ?</p></li>
<li><p>Để xác định khoảng cách giữa các cụm, chúng ta có những phương pháp đo lường nào?</p></li>
<li><p>Phương pháp đo lường khoảng cách cụm theo <em>ward linkage</em> chỉ phù hợp khi dữ liệu tồn tại trong không gian nào?</p></li>
<li><p>Có những phương pháp nào để dừng quá trình phân cụm?</p></li>
<li><p>Sử dụng bộ dữ liệu <a class="reference external" href="https://archive.ics.uci.edu/ml/datasets/wine">wine</a> hãy phân chia tập train/test và khảo sát bộ dữ liệu.</p></li>
<li><p>Thực hiện giảm chiều dữ liệu và chuẩn hoá dữ liệu đầu vào.</p></li>
<li><p>Xây dựng mô hình phân cụm chất lượng rượi từ các trường dữ liệu đầu vào. Lưu ý không sử dụng biến mục tiêu trong quá trình huấn luyện.</p></li>
<li><p>Sử dụng biến mục tiêu thật từ bộ dữ liệu để đánh giá độ chính xác của thuật toán phân cụm. Biểu đồ hoá phân phối các cụm trong không gian hai chiều.</p></li>
</ol>
</div>
<div class="tex2jax_ignore mathjax_ignore section" id="tai-lieu-tham-khao">
<h1>14.9. Tài liệu tham khảo<a class="headerlink" href="#tai-lieu-tham-khao" title="Permalink to this headline">¶</a></h1>
<ol class="simple">
<li><p><a class="reference external" href="https://web.stanford.edu/~hastie/ElemStatLearn/">The Elements of Statistical Learning, page 520-528</a></p></li>
<li><p><a class="reference external" href="https://statweb.stanford.edu/~jtaylo/courses/stats202/restricted/notes/week9_2x2.pdf">https://statweb.stanford.edu/~jtaylo/courses/stats202/restricted/notes/week9_2x2.pdf</a></p></li>
<li><p><a class="reference external" href="https://nlp.stanford.edu/IR-book/html/htmledition/hierarchical-agglomerative-clustering-1.html">https://nlp.stanford.edu/IR-book/html/htmledition/hierarchical-agglomerative-clustering-1.html</a></p></li>
<li><p><a class="reference external" href="http://www.econ.upf.edu/~michael/stanford/maeb7.pdf">http://www.econ.upf.edu/~michael/stanford/maeb7.pdf</a></p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=rg2cjfMsCk4">https://www.youtube.com/watch?v=rg2cjfMsCk4</a></p></li>
<li><p><a class="reference external" href="https://jbhender.github.io/Stats506/F18/GP/Group10.html">https://jbhender.github.io/Stats506/F18/GP/Group10.html</a></p></li>
<li><p><a class="reference external" href="https://stackabuse.com/hierarchical-clustering-with-python-and-scikit-learn/">https://stackabuse.com/hierarchical-clustering-with-python-and-scikit-learn/</a></p></li>
</ol>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./ch_ml"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="index_HierarchicalClustering.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">14. Hierarchical Clustering (<em>phân cụm phân cấp</em>)</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="index_DBSCAN.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">15. DBSCAN</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Pham Dinh Khanh<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>